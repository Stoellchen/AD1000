## https://devices.esphome.io/devices/M5Stack-Dial
## https://docs.m5stack.com/en/core/M5Dial
## https://github.com/GinAndBacon/ESPHome-LVGL-EncoderDial/tree/main
## https://aguacatec.es/integrar-m5stack-dial-en-ha/
## sounds:   https://1j01.github.io/rtttl.js/#Bolero  +  https://rtttl.skully.tech/




substitutions:
  background_color: 'fab02b'
  background_image: m5dial-main-syd-02/images/syd_background_white.jpg
  background_image_saver: m5dial-main-syd-02/images/syd_bg_off.jpg
  background_image_device: m5dial-main-syd-02/images/syd_bg_device.jpg
  background_image_saver_date_time: m5dial-main-syd-02/images/syd_bg_device_off_date_time.jpg



# Icons
# Iconos
#  icon_1: mdi:led-strip-variant
#  icon_2: mdi:thermostat
#  icon_3: mdi:robot-vacuum
#  icon_4: mdi:printer
#  icon_5: mdi:printer-3d-nozzle
#  icon_6: mdi:fan
#  icon_7: mdi:air-humidifier
#  icon_8: mdi:ceiling-light

  pageicon_plus: mdi:plus
  pageicon_minus: mdi:minus
  pageicon_back: mdi:arrow-left
  pageicon_light_off: mdi:lightbulb-off
  pageicon_light_on: mdi:lightbulb
  pageicon_switch_off: mdi:power-plug-outline
  pageicon_switch_on: mdi:power-plug
  pageicon_switch_una: mdi:power-plug-off

  pageicon_media_play: mdi:play
  pageicon_media_stop: mdi:stop
  pageicon_media_play_pause: mdi:play-pause
  pageicon_media_volume_plus: mdi:volume-plus
  pageicon_media_volume_minus: mdi:volume-minus
  pageicon_media_volume_mute: mdi:volume-mute
  pageicon_media_standby: mdi:power-standby
  
  pageicon_00: mdi:home-outline
  pageicon_10: mdi:lightbulb-on-outline
  pageicon_20: mdi:switch
  pageicon_30: mdi:speaker-play
  pageicon_40: mdi:air-conditioner
  pageicon_50: mdi:help
  pageicon_60: mdi:help
  pageicon_70: mdi:map-marker-multiple-outline
  pageicon_80: mdi:information-outline
  pageicon_90: mdi:shield-account



# Sounds
# Sonidos
  menu_sound: 'beep:d=64,o=5,b=255:c7'
  alarm_sound: 'xmen:d=4,o=6,b=200:16f#5,16g5,16b5,16d,c#,8b5,8f#5,p,16f#5,16g5,16b5,16d,c#,8b5,8g5,p,16f#5,16g5,16b5,16d,c#,8b5,8d,2p,8c#,8b5,2p'
  
  sound_menu_clockwise: 'menuclockwise:d=4,o=7,b=225:16c4'
  sound_menu_cclockwise: 'menucclockwise:d=4,o=7,b=225:16f4'
  sound_menu_press: 'menupress:d=2,o=7,b=225:16b4'

  sound_agado: 'agadoo:d=8,o=5,b=125,b=125:b,g#,4e,e,e,4e,e,e,e,e,d#,e,4f#,a,f#,4d#,d#,d#,4d#,d#,d#,d#,d#,c#,d#,4e'
  sound_axel: 'axel:d=8,o=5,b=125,b=125:16g,16g,a#.,16g,16p,16g,c6,g,f,4g,d6.,16g,16p,16g,d#6,d6,a#,g,d6,g6,16g,16f,16p,16f,d,a#,2g,4p,16f6,d6,c6,a#,4g,a#.,16g,16p,16g,c6,g,f,4g,d6.,16g,16p,16g,d#6,d6,a#,g,d6,g6,16g,16f,16p,16f,d,a#,2g'
  sound_bolero: 'bolero:d=16,o=5,b=80,b=80:c6,8c6,b,c6,d6,c6,b,a,8c6,c6,a,4c6,8c6,b,c6,a,g,e,f,2g,g,f,e,d,e,f,g,a,4g,4g,g,a,b,a,g,f,e,d,e,d,8c,8c,c,d,8e,8f,4d,2g'
  sound_bond: '007:d=4,o=5,b=320,b=320:c,8d,8d,d,2d,c,c,c,c,8d#,8d#,2d#,d,d,d,c,8d,8d,d,2d,c,c,c,c,8d#,8d#,d#,2d#,d,c#,c,c6,1b.,g,f,1g.'
  sound_borteus: 'borteus:d=16,o=5,b=160,b=160:b,p,c6,p,d6,b,g,e,b,g,e,c,g,e,c,a4,4p,c6,p,d6,p,e6,c6,a,f,c6,a,f,d,a,f,d,b4,2p,g6,e6,c6,a,f,d,b4,c6,a,f,d,b4,f,d,b4,f,4e.'
  sound_colonel: 'colonel bogey:d=8,o=5,b=140,b=140:g,e,4p,p,e,f,g,e6,p,e6,p,2c6,g,e,4p,p,e,f,e,g,p,g,p,2f,f,d,4p,p,d,e,f,g,e,4p,p,e,f#,e,d,g,p,e,f#,d,p,a,g.,16f#,g,a,g,f,e,d'
  sound_dallas: 'Dallas:d=8,o=5,b=125,b=125:e,4a.,e,4e6.,a,4c#6,b,c#6,4a,4e,4a,4f#6,4e6,c#6,d6,2e6.,p,e,4a,4f#6,4e6,c#6,d6,4e6,b,c#6,4a,4e,4a,c#6,d6,4b.,a,2a'
  sound_final: 'Final Countdown:d=16,o=5,b=125,b=125:b,a,4b,4e,4p,8p,c6,b,8c6,8b,4a,4p,8p,c6,b,4c6,4e,4p,8p,a,g,8a,8g,8f#,8a,4g.,f#,g,4a.,g,a,8b,8a,8g,8f#,4e,4c6,2b.,b,c6,b,a,1b'
  sound_flintstones: 'Flintstones:d=8,o=5,b=200,b=200:g#,4c#,p,4c#6,a#,4g#,4c#,p,4g#,f#,f,f,f#,g#,4c#,4d#,2f,2p,4g#,4c#,p,4c#6,a#,4g#,4c#,p,4g#,f#,f,f,f#,g#,4c#,4d#,2c#'
  sound_fruit: 'Fruit and Nut:d=16,o=5,b=70:d,c#,d,c#,d,p,c#,p,e,p,32d,32f#,32a,32d6,8f#.6,p,g6,f#6,g6,f#6,e6,d6,a,f#,8d.,32f#,32d6,8c#.6,p,b,b4,b4,32b4,32c#,b4,p,a4,p,b,b4,b4,32b4,32c#,b4,p,a4,p,d6,d,d,d,d,c#,e,d,d,c#,b4,a4,8g6,32e6,32c#6,32g,32e,d,c#,d,c#,d,p,c#,p,e,p,32d,32f#,32a,32d6,8f#.6,32p,g6,f#6,g6,f#6,e6,d6,a,f#,8d.,32f#,32d6,8c#.6,p,b,b4,b4,32b4,32c#,b4,p,a4,p,b,b4,b4,32b4,32c#,b4,p,a4,p,b,b4,8b4,8c#,32p,8c#,8d.'
  sound_hawaii: 'Hawaii 5 0:d=16,o=6,b=240:8g#5,p,8g#5,p,8b5,p,4d#,p,2c#.,p,2g#5.,p,8g#5,p,8g#5,p,8f#5,p,4b5,p,1g#5,4p.,8g#5,p,8g#5,p,8b5,p,4d#,p,2c#,8p,2g#.,8p,8f#,p,8f#,p,8d#,p,4b5,p,1g#.,4p,2b,p,8a,8g#,8f#,8e,8d#,8c#,8d#,8b5,2c#,4p,8c#,p,8b,8a,8g,8f#,8d#,8c#,8b5,8c#,4d#,8c#,p,4b5,p,4c#.,p,2g#,4p,8f#,p,8f#,p,8d#,p,4b5,p,1c#6'
  sound_knight: 'Knight Rider:d=32,o=5,b=63,b=63:16e,f,e,8b,16e6,f6,e6,8b,16e,f,e,16b,16e6,4d6,8p,4p,16e,f,e,8b,16e6,f6,e6,8b,16e,f,e,16b,16e6,4f6'
  sound_letitbe: 'Let it be:d=8,o=5,b=100,b=100:16e6,d6,4c6,16e6,g6,a6,g6.,16g6,g6,e6,16d6,c6,16a,g,4e6.,4p,e6,16e6,f6.,e6,e6,d6,16p,16e6,16d6,d6,2c6..'
  sound_mission: 'Mission Impossible:d=16,o=5,b=100:32d,32d#,32d,32d#,32d,32d#,32d,32d#,32d,32d,32d#,32e,32f,32f#,32g,g,8p,g,8p,a#,p,c6,p,g,8p,g,8p,f,p,f#,p,g,8p,g,8p,a#,p,c6,p,g,8p,g,8p,f,p,f#,p,a#,g,2d,32p,a#,g,2c#,32p,a#,g,2c,p,a#4,c'
  sound_mozart: 'Mozart:d=16,o=5,b=125:16d#,c#,c,c#,8e,8p,f#,e,d#,e,8g#,8p,a,g#,g,g#,d#6,c#6,c6,c#6,d#6,c#6,c6,c#6,4e6,8c#6,8e6,32b,32c#6,d#6,8c#6,8b,8c#6,32b,32c#6,d#6,8c#6,8b,8c#6,32b,32c#6,d#6,8c#6,8b,8a#,4g#,d#,32c#,c,c#,8e,8p,f#,e,d#,e,8g#,8p,a,g#,g,g#,d#6,c#6,c6,c#6,d#6,c#6,c6,c#6,4e6,8c#6,8e6,32b,32c#6,d#6,8c#6,8b,8c#6,32b,32c#6,d#6,8c#6,8b,8c#6,32b,32c#6,d#6,8c#6,8b,8a#,4g#'
  sound_muppet: 'Muppet:d=8,o=5,b=250:c6,4c6,4a,4b,a,4b,4g,4p,4c6,4c6,4a,b,a,p,4g.,4p,4e,4e,4g,4f,e,4f,c6,c,d,4e,e,e,p,e,4g,2p,4c6,4c6,4a,4b,a,4b,4g,4p,4c6,4c6,4a,b,4a,4g.,4p,4e,4e,4g,4f,e,4f,c6,c,d,4e,e,4d,d,4c'
  sound_newyear: 'New Year:d=8,o=5,b=125,b=125:a4,4d.,d,4d,4f#,4e.,d,4e,f#,e,4d.,d,4f#,4a,2b.,4b,4a.,f#,4f#,4d,4e.,d,4e,f#,e,4d.,b4,4b4,4a4,2d,16p'
  sound_popcorn: 'Popcorn:d=16,o=5,b=160:a,p,g,p,a,p,e,p,c,p,e,p,8a4,8p,a,p,g,p,a,p,e,p,c,p,e,p,8a4,8p,a,p,b,p,c6,p,b,p,c6,p,a,p,b,p,a,p,b,p,g,p,a,p,g,p,a,p,f,8a,8p,a,p,g,p,a,p,e,p,c,p,e,p,8a4,8p,a,p,g,p,a,p,e,p,c,p,e,p,8a4,8p,a,p,b,p,c6,p,b,p,c6,p,a,p,b,p,a,p,b,p,g,p,a,p,g,p,a,p,b,4c6'
  sound_quofnigt: 'QuoFNigt:d=8,o=5,b=160:16a,16g,16a,16a#,c6,c6,c6,c6,c6,c6,c6,c6,4f.,4p,32f,16e,16f,16g,a,a,a,a,a,a,a,a,4d.,4p,16d,16c,16d,16e,f,f,f,c,g,g,g,c,a,f,a,c6,f6,c6,d6,a#,c6,f,a,c6,f6,c6,d6,a#,4c6,4p,4f.,f,4a4,4p,4e,4p,f,g,f,a,a#,a,f,g,f,d,e,d,c#,d,c#,a4,b4,a4,c#,d,c#,e,f,e,f,g,f,a,a#,a,f,g,f,d,e.'
  sound_rudolf: 'Rudolph the Red Nosed Raindeer:d=8,o=5,b=250:g,4a,g,4e,4c6,4a,2g.,g,a,g,a,4g,4c6,2b.,4p,f,4g,f,4d,4b,4a,2g.,g,a,g,a,4g,4a,2e.,4p,g,4a,a,4e,4c6,4a,2g.,g,a,g,a,4g,4c6,2b.,4p,f,4g,f,4d,4b,4a,2g.,g,a,g,a,4g,4d6,2c.6,4p,4a,4a,4c6,4a,4g,4e,2g,4d,4e,4g,4a,4b,4b,2b,4c6,4c6,4b,4a,4g,4f,2d,g,4a,g,4e,4c6,4a,2g.,g,a,g,a,4g,4c6,2b.,4p,f,4g,f,4d,4b,4a,2g.,4g,4a,4g,4a,2g,2d6,1c.6.'
  sound_startrek: 'Star Trek:d=16,o=5,b=63,b=63:8f.,a#,4d#6.,8d6,a#.,g.,c6.,4f6'
  sound_starwars: 'Star Wars:d=8,o=6,b=180,b=180:f5,f5,f5,2a#5.,2f.,d#,d,c,2a#.,4f.,d#,d,c,2a#.,4f.,d#,d,d#,2c,4p,f5,f5,f5,2a#5.,2f.,d#,d,c,2a#.,4f.,d#,d,c,2a#.,4f.,d#,d,d#,2c'
  sound_takeonme: 'Take On Me:d=8,o=5,b=160,b=160:f#,f#,f#,d,p,b4,p,e,p,e,p,e,g#,g#,a,b,a,a,a,e,p,d,p,f#,p,f#,p,f#,e,e,f#,e,f#,f#,f#,d,p,b4,p,e,p,e,p,e,g#,g#,a,b,a,a,a,e,p,d,p,f#,p,f#,p,f#,e,e5'
  sound_theateam: 'The A Team:d=8,o=5,b=132,b=132:4d#6,a#,2d#6,16p,g#,4a#,4d#.,p,16g,16a#,d#6,a#,f6,2d#6,16p,c#6.,16c6,16a#,g#.,2a#.'
  sound_titanic: 'Titanic:d=8,o=6,b=120,b=120:c,d,2e.,d,c,d,g,2g,f,e,4c,2a5,g5,f5,16d5,16e5,2d5,p,c,d,2e.,d,c,d,g,2g,e,g,2a,2g,16d,16e,2d.'
  sound_vanessamae: 'Vanessa Mae:d=16,o=5,b=140:c6,b,8c6,g,p,g,p,d#,p,d#,p,c,p,c,p,c6,b,8c6,g#,p,g#,p,f,p,8f,c,p,c,p,c6,b,8c6,g,p,g,p,d#,p,d#,p,c,p,c,p,g,f,d#,d,c,d,d#,c,d#,f,8g,8p,8d6,c6,d6,a#,d6,a,d6,g,d6,d6,p,d6,p,d6,p,8d6,c6,d6,a#,d6,a,d6,g,d6,d6,p,d6,p,d6,p,g,f,d#,d,c,d,d#,c,d#,f,4c.'
  sound_waltons: 'Waltons:d=4,o=5,b=120:8d,8d,g,a,b,1b.,2p,8d,8d,g,a,b,2b,1c#.6,8a,8a,e6,d6,c#6,2d.6,1a,p,8a,8a,a,b.,8c6,1b.,2p,8d,8d,g,a,b,1b.,2p,8d,8d,g,a,b,2b,1c#.6,8a,8a,e6,d6,c#6,2d.6,1a,p,8a,8a,a,b.,8a,1g.,2p,a,2b,d6,2e.6,2f.6,2g6,8e6,8e6,g6,f6,e6,1d.6,2p,8d6,8d6,f6,e6,d6,1a.,2p,8a,8b,c6,d6,c6,1b.,2p,a,2b,d6,2e.6,2f.6,2g.6,g6,f#6,e6,2g.6,1d6,p,8d6,8d6,g6,f6,e6,1c.6,2p,8a,8a,d6,c6,b,1g.,2p,8d,8d,g,a,b,1b.,2p,8d,8d,g,a,b,2b,1c#.6,8a,8a,e6,d6,c#6,2d.6,1a,p,8a,8a,a,b.,8a,1g..'




# NFC/RFID Tags
# Etiquetas NFC/RFID
#  tag1: C3-DB-4F-28
#  tag2: 03-55-E5-13
# Other settings
# Otros ajustes
  allowed_characters: " Â¿?Â¡!#%'()+,-./:Â°0123456789ABCDEFGHIJKLMNOPQRSTUVWYZabcdefghijklmnopqrstuvwxyzÃ¡Ã©Ã­Ã³Ãº"
################################################################################################################


# external_components:
#  - source:
#      type: local
#      path: m5dial-main-syd-02/components
#    components:
#      - switch_store

esphome:
  name: ${name}
  name_add_mac_suffix: false
  friendly_name: ${friendly_name}
  includes:
#    - m5dial-main-syd-02/components/switch_store/switch_store.h
#    - m5dial-main-syd-02/components/switch_store/split_util.h

  on_boot:
    then:
      - pcf8563.read_time:
      - lambda: |-
          id(this_device) = App.get_name();
          ESP_LOGD("boot", "GerÃ¤tename gespeichert: %s", id(this_device).c_str());
      - lambda: 'id(current_page) = "p00";'
      - display.page.show: p00
      - lambda: |-
          id(matrix_drops).clear();
          for (int i = 0; i < 20; i++) {
            int x = esp_random() % 240;
            int y = esp_random() % 240;
            char ch = 'A' + (esp_random() % 26);
            id(matrix_drops).push_back(std::make_tuple(x, y, ch));
          }


  platformio_options:
    board_build.flash_mode: dio
    build_flags: -I include

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 8MB
  framework:
    type: arduino



# Enable Home Assistant API
api:
  encryption:
#    key: "tEBGrpth5CDdrDidl4Ur1gFNoSOWIg0aeUmV/1s5wmg="
    key: !secret api_encryption_key
  services:
    - service: play_sound
      variables:
        song: string
        volume: int 
      then:
        - lambda: "id(script_rtttl_play).execute(song, volume);"

ota:
  - platform: esphome
    password: !secret ota_encrpytion_key 

wifi:
  # ssid: !secret wifi_ssid
  # password: !secret wifi_password
  # ssid: ReseauTemplier2
  # password: K5Zt53rT&4428
  fast_connect: !secret wifi2_fast_connect
  # power_save_mode: !secret wifi2_power_save_mode
  networks:
  - ssid: !secret wifi2_ssid
    password: !secret wifi2_password
    priority: !secret wifi2_priority
  - ssid: !secret wifi2_ssid_2
    password: !secret wifi2_password_2
    priority: !secret wifi2_priority_2
  - ssid: !secret wifi2_ssid_3
    password: !secret wifi2_password_3
    priority: !secret wifi2_priority_3
  - ssid: !secret wifi2_ssid_4
    password: !secret wifi2_password_4
    priority: !secret wifi2_priority_4
  - ssid: !secret wifi2_ssid_5
    password: !secret wifi2_password_5
    priority: !secret wifi2_priority_5
  domain: !secret wifi2_domain
  

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${short_name} Fallback Hotspot"
    password: !secret ap_password

mqtt:
  id: mqtt_client  # ðŸ‘ˆ Das brauchst du!
  broker: !secret m5dial_mqtt_broker
  username: !secret m5dial_mqtt_user
  password: !secret m5dial_mqtt_password
  discovery: false  # optional: verhindert auto-discovery in Home Assistant
  topic_prefix: m5dial_01  # optional: eindeutiger MQTT-Namensraum fÃ¼r das GerÃ¤t
  birth_message:
    topic: m5dial/m5dial_01/status
    payload: online
  will_message:
    topic: m5dial/m5dial_01/status
    payload: offline
  on_message:
    # fÃ¼r lichter info liste
    - topic: m5dial/lights
      then:
        - lambda: |-
            id(m5_list_lights).publish_state(x);
    # fÃ¼r switches info liste
    - topic: m5dial/switXXXXches
      then:
        - lambda: |-
            id(m5_list_switches).publish_state(x);
    # fÃ¼r media info liste
    - topic: m5dial/media
      then:
        - lambda: |-
            id(m5_list_media).publish_state(x);
    # fÃ¼r aircon info liste
    - topic: m5dial/aircon
      then:
        - lambda: |-
            id(m5_list_aircon).publish_state(x);
    # fÃ¼r statusmessage fÃ¼r entsprechende selektion auf dem M5
    # - topic: m5dial/+/status/+
    - topic: m5dial/${name}/status/+
      then:
        - lambda: |-
            ESP_LOGD("mqtt", "Status empfangen: %s", x.c_str());
            // Hier: JSON parsen und in Variablen speichern
            

  on_json_message:
    # - topic: m5dial/+/status/light/+
    # - topic: !lambda 'return "m5dial/" + id(this_device) + "/status/light/+";'
    - topic: m5dial/${name}/status/light/+
      then:
      - lambda: |-
          if (x.containsKey("state")) {
            std::string state = x["state"].as<std::string>();
            id(current_light_state) = (state == "on");
            ESP_LOGD("mqtt", "State empfangen: %s", state.c_str());
          }

          if (x.containsKey("brightness")) {
            id(current_light_brightness) = x["brightness"].as<int>();
            ESP_LOGD("mqtt", "Helligkeit empfangen: %d", id(current_light_brightness));
          }

          if (x.containsKey("color")) {
            auto color = x["color"];
            if (color.is<JsonArray>()) {
              int r = color[0].as<int>();
              int g = color[1].as<int>();
              int b = color[2].as<int>();
              id(current_light_color) = Color(r, g, b);
              ESP_LOGD("mqtt", "Farbe empfangen: R=%d G=%d B=%d", r, g, b);
            }
          }
    # - topic: m5dial/+/status/room/light/+
    # - topic: !lambda 'return "m5dial/" + id(this_device) + "/status/room/light/+";'
    - topic: m5dial/${name}/status/room/light/+
      then:
        - lambda: |-
            if (x.containsKey("brightness")) {
              int brightness = x["brightness"].as<int>();
              id(current_light_brightness) = brightness;
              ESP_LOGD("mqtt", "Raumhelligkeit empfangen: %d", brightness);
            }

            if (x.containsKey("color")) {
              auto color = x["color"];
              if (color.is<JsonArray>()) {
                int r = color[0].as<int>();
                int g = color[1].as<int>();
                int b = color[2].as<int>();
                id(current_light_color) = Color(r, g, b);
                ESP_LOGD("mqtt", "Raumfarbe empfangen: R=%d G=%d B=%d", r, g, b);
              }
            }

    - topic: m5dial/activity/monitoring
      then:
        - lambda: |-
            std::string typ = x["type"] | "";
            std::string entity = x["entity"] | "";
            std::string name = x["name"] | "";
            std::string from = x["from"] | "";
            std::string to = x["to"] | "";
            std::string ts = x["ts"] | "";

            ESP_LOGD("activity", "Typ=%s  Entity=%s  Name=%s  %s â†’ %s (%s)", 
              typ.c_str(), entity.c_str(), name.c_str(), from.c_str(), to.c_str(), ts.c_str());

            // Jetzt den Script aufrufen
            id(track_activity_event_monitoring).execute(typ, entity, ts);


    # Antwort auf Anfrage: Alle RÃ¤ume (nur Namen)
    # - topic: m5dial/+/response/switches/rooms
    # - topic: !lambda 'return "m5dial/" + id(this_device) + "/response/switches/rooms/+";'
    - topic: m5dial/${name}/response/switches/rooms/
      then:
        - lambda: |-
            std::string output;
            serializeJson(x, output);
            id(global_m5_switches_rooms) = output;
            ESP_LOGD("mqtt", "[rooms] JSON empfangen: %s", output.c_str());

    # - topic: m5dial/+/response/switches/room
    #- topic: !lambda 'return "m5dial/" + id(this_device) + "/response/switches/room";'
    - topic: m5dial/${name}/response/switches/room
      then:
        - lambda: |-
            std::string output;
            serializeJson(x, output);
            id(global_m5_switches_by_room) = output;
            ESP_LOGD("mqtt", "[room] JSON empfangen: %s", output.c_str());


    # - topic: m5dial/+/response/switches/device 
    # - topic: !lambda 'return "m5dial/" + id(this_device) + "/response/switches/device";'
    - topic: m5dial/${name}/response/switches/device
      then:
        - lambda: |-
            std::string output;
            serializeJson(x, output);
            id(global_m5_switches_by_device) = output;
            ESP_LOGD("mqtt", "[device] JSON empfangen: %s", output.c_str());

    # - topic: m5dial/+/response/switches/device 
    # - topic: !lambda 'return "m5dial/" + id(this_device) + "/response/switches/device";'
    - topic: m5dial/${name}/response/tracking/ble
      then:
        - lambda: |-
            if (x.containsKey("payload")) {
              std::string payload = x["payload"].as<std::string>();
              // ESP_LOGI("BLE", "Received BLE Payload: %s", payload.c_str());
              id(global_m5_tracking_ble) = payload;
            } else {
              ESP_LOGW("BLE", "Payload key missing in JSON message!");
            }  

    # Antwort auf Anfrage: Alle RÃ¤ume (nur Namen)
    # - topic: m5dial/+/response/switches/rooms
    # - topic: !lambda 'return "m5dial/" + id(this_device) + "/response/switches/rooms/+";'
    - topic: m5dial/${name}/response/media/rooms/
      then:
        - lambda: |-
            std::string output;
            serializeJson(x, output);
            id(global_m5_media_rooms) = output;
            ESP_LOGD("mqtt", "[rooms] JSON empfangen: %s", output.c_str());

    - topic: m5dial/${name}/response/media/room/player
      then:
        - lambda: |-
        - lambda: |-
            std::string output;
            serializeJson(x, output);
            id(global_m5_media_by_room) = output;
            ESP_LOGD("mqtt", "[room] JSON empfangen: %s", output.c_str());

script:
  - id: track_activity_event_monitoring
    mode: parallel
    parameters:
      typ: string
      entity: string
      ts: string
    then:
      - lambda: |-
          const std::string &type = typ;
          const std::string &ent = entity;
          const std::string &timestamp = ts;

          // Aktuelle Zeit in Sekunden (als float)
          auto now = id(esptime).now().timestamp;

          // Cleanup: Alte EintrÃ¤ge (>5min) rauswerfen
          std::vector<std::tuple<std::string, std::string, float>> neu;
          for (auto &e : id(global_activity_monitoring_events)) {
            float t = std::get<2>(e);
            if ((now - t) <= 300) {
              neu.push_back(e);
            }
          }
          id(global_activity_monitoring_events) = neu;

          // PrÃ¼fen ob Entity bereits vorhanden
          bool found = false;
          for (auto &e : id(global_activity_monitoring_events)) {
            if (std::get<1>(e) == ent) {
              std::get<2>(e) = now;  // Update Zeitstempel
              found = true;
              break;
            }
          }

          if (!found) {
            id(global_activity_monitoring_events).push_back({type, ent, now});
          }

          ESP_LOGD("activity", "Eintrag %s (%s) registriert, gesamt: %d", ent.c_str(), type.c_str(), id(global_activity_monitoring_events).size());

  ## smart publish - not too many mqtt in the system
  - id: smart_mqtt_publish
    mode: parallel
    parameters:
      topic: string
      payload: string
      key: string  # z.â€¯B. "p1000", "p10000", "media"
      custom_timeout: int
    then:
      - lambda: |-
          unsigned long now = millis();
          unsigned long timeout = 1000;

          if (key == "touch") {
            timeout = 200;
          }

          // Falls custom_timeout gesetzt ist (> 0), verwende ihn (zwischen 200â€“5000 ms)
          // 	1.	(unsigned long) custom_timeout
          //    Konvertiert den Ã¼bergebenen Wert in einen unsigned long, da std::min und std::max hier mit UL (unsigned long) Literalen arbeiten.
          //  2.	std::max(200UL, ...)
          //    Wenn custom_timeout < 200, wird 200 zurÃ¼ckgegeben. Dadurch ist der Wert mindestens 200â€¯ms.
          //  3.	std::min(5000UL, ...)
          //    Begrenzung nach oben: Wenn custom_timeout > 5000, wird 5000 zurÃ¼ckgegeben. Dadurch ist der Wert hÃ¶chstens 5000â€¯ms.
          if ( custom_timeout > 0) {
            timeout = std::min(5000UL, std::max(200UL, (unsigned long) custom_timeout));
          }

          if (!id(mqtt_last_publish).count(key) || now - id(mqtt_last_publish)[key] > timeout) {
            id(mqtt_last_publish)[key] = now;
            id(mqtt_client)->publish(topic, payload);
            ESP_LOGD("smart_mqtt", "MQTT (%s, %lu ms): %s â†’ %s", key.c_str(), timeout, topic.c_str(), payload.c_str());
          } else {
            // ESP_LOGD("smart_mqtt", "MQTT skipped (%s): %lu ms < %lu ms", key.c_str(), now - id(mqtt_last_publish)[key], timeout);
          }


  - id: smart_mqtt_publish_old1
    mode: parallel
    parameters:
      topic: string
      payload: string
      key: string  # z.â€¯B. "p1000", "p10000", "media"
    then:
      - lambda: |-
          unsigned long now = millis();
          unsigned long timeout = (key == "touch") ? 200 : 1000;

          if (!id(mqtt_last_publish).count(key) || now - id(mqtt_last_publish)[key] > timeout) {
            id(mqtt_last_publish)[key] = now;
            id(mqtt_client)->publish(topic, payload);
            ESP_LOGD("smart_mqtt", "MQTT (%s, %dms): %s â†’ %s", key.c_str(), timeout, topic.c_str(), payload.c_str());
          } else {
            // ESP_LOGD("smart_mqtt", "MQTT skipped (%s): %lu ms < %lu ms", key.c_str(), now - id(mqtt_last_publish)[key], timeout);
          }


  - id: reset_inactivity
    mode: queued
    then:
      - lambda: |-
          id(inactivity_time) = 0;

          // Display aktivieren wenn nÃ¶tig
          if (!id(syd_display).state) {
            id(syd_display).turn_on();
          }

          // Screensaver ggf. beenden
          if (id(screen_saver).state) {
            id(screen_saver).turn_off();
          }

          // Falls das Display auf "locked_screen" ist â†’ zurÃ¼ck auf p00
          if (id(current_page) == "locked_screen") {
            id(current_page) = "p00";
            id(round_display).show_page(p00);
          }

  - id: script_rtttl_play
    parameters:
      song: string
      volume: int 
    mode: single
    then:
      - lambda: |-
          float volume_f = (volume>0) ? ((float)clamp(volume, 0, 100))/100.0f : 1.0f;
          id(buzzer).set_max_power(volume_f);
      - rtttl.play:
          rtttl: !lambda 'return (song.find('':'') == std::string::npos) ? ("song:d=16,o=5,b=100:" + song).c_str() : song.c_str();'


  - id: script_play_sound
    parameters:
      rtttlsong: string
    mode: single
    then:
      - if:
          condition:
            switch.is_on: menu_sounds
          then:
#          - rtttl.play: ${rtttlsong}
          - rtttl.play: 
              rtttl: !lambda 'return rtttlsong;'

  - id: play_selected_sound
    parameters:
      rtttlsong: string
    mode: single
    then:
      - if:
          condition:
            lambda: 'return rtttlsong.length() > 0;'
          then:
            - rtttl.play:
                rtttl: !lambda 'return rtttlsong;'

  - id: wake_up_display
    then:
      - switch.turn_on: syd_display
      - light.turn_on:
          id: backlight
          brightness: 100%
      - lambda: 'id(current_page) = "p00";'
      - display.page.show: p00
      - script.execute: reset_inactivity

  - id: init_matrix_drops
    then:
      - lambda: |-
          id(matrix_drops).clear();
          for (int i = 0; i < 20; i++) {
            int x = esp_random() % 240;
            int y = esp_random() % 240;
            char ch = 'A' + (esp_random() % 26);
            id(matrix_drops).push_back(std::make_tuple(x, y, ch));
          }



logger:
  level: DEBUG
#  level: ERROR # nur wenn fehler auftauchen

# Package to find devices if not labeled
# packages:
#  identify: !include ./m5-identify-me.yaml   = kein LED um zu blinken, nur das backlight
#  # identify: !include common-m5-stuff/m5-identify-me.yaml

captive_portal:

## das ist zuviel fuer das board!!!
## M5 Dial sollte dies auch zusÃ¤tzlich kÃ¶nnen. !!!
# âž¤ BLE-Tracker aktivieren
# esp32_ble_tracker:
# âž¤ Optional: BLE-Proxy fÃ¼r Home Assistant aktivieren
# bluetooth_proxy:
#  active: true


binary_sensor:
  - platform: touchscreen
    name: "Center Select (locked_screen)"
    internal: true
    x_min: 80
    x_max: 160
    y_min: 80
    y_max: 160
    page_id: locked_screen
    on_press:
      then:
        - script.execute: wake_up_display


  ## reihenfolge so ist massgebend !!
  - platform: touchscreen
    name: "p10000 Select Device Details"
    internal: true
    page_id: p10000
    x_min: 80
    x_max: 160
    y_min: 80
    y_max: 104
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(current_page) == "p10000";'
            then:
              - lambda: |-
                  ESP_LOGD("touch", "Center-Click in Raumgruppe erkannt. Wechsle zu p100000");
              - lambda: 'id(selected_sub_sub_index) = 0;'
              - lambda: |-
                  id(script_play_sound).execute("${sound_menu_press}");
              - lambda: 'id(current_page) = "p100000";'
              - display.page.show: p100000
              - script.execute: reset_inactivity


  ## reihenfolge so ist massgebend !!
  - platform: touchscreen
    name: "p1000 Select Device Group"
    internal: true
    page_id: p1000
    x_min: 80
    x_max: 160
    y_min: 80
    y_max: 104
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(current_page) == "p1000";'
            then:
              - lambda: |-
                  ESP_LOGD("touch", "Center-Click in Raumgruppe erkannt. Wechsle zu p10000");
              - lambda: 'id(selected_sub_sub_index) = 0;'
              - lambda: |-
                  id(script_play_sound).execute("${sound_menu_press}");
              - lambda: 'id(current_page) = "p10000";'
              - display.page.show: p10000
              - script.execute: reset_inactivity

  ## reihenfolge so ist massgebend !!
  - platform: touchscreen
    name: "p2000 Select Room Devices Group"
    internal: true
    page_id: p2000
    x_min: 80
    x_max: 160
    y_min: 80
    y_max: 104
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(current_page) == "p2000";'
            then:
              - lambda: |-
                  ESP_LOGD("touch", "Center-Click in Raumgruppe erkannt. Wechsle zu p20000");
              - lambda: 'id(selected_sub_sub_index) = 0;'
              - lambda: |-
                  id(script_play_sound).execute("${sound_menu_press}");
              - lambda: 'id(current_page) = "p20000";'
              - display.page.show: p20000
              - script.execute: reset_inactivity


  ## reihenfolge so ist massgebend !!
  - platform: touchscreen
    name: "p00 Center Select"
    internal: true
    x_min: 80
    x_max: 160
    y_min: 80
    y_max: 160
    page_id: p00
    on_press:
      then:
        - script.execute: reset_inactivity
        - lambda: |-
            ESP_LOGD("touch", "Current Page: %s", id(current_page).c_str());
        - if:
            condition:
              display.is_displaying_page: locked_screen
            then:
            - script.execute: wake_up_display
        ## selektion des devices
        - if:
            condition:
              display.is_displaying_page: p00
            then:
            # lichter
            - if:
                condition:
                  lambda: return id(selected_index) == 1;
                then:
                  - lambda: |-
                      id(selected_sub_index) = 0;
                  - lambda: 'id(current_page) = "p1000";'
                  - display.page.show: p1000
            # switches
            - if:
                condition:
                  lambda: return id(selected_index) == 2;
                then:
                  - lambda: |-
                      id(selected_sub_index) = 0;
                  - lambda: 'id(current_page) = "p2000";'
                  - display.page.show: p2000
            # media
            - if:
                condition:
                  lambda: return id(selected_index) == 3;
                then:
                  - lambda: |-
                      id(selected_sub_index) = 0;
                  - lambda: 'id(current_page) = "p3000";'
                  - display.page.show: p3000
            # map
            - if:
                condition:
                  lambda: return id(selected_index) == 7;
                then:
                  - lambda: |-
                      id(selected_sub_index) = 0;
                  - lambda: 'id(current_page) = "p70";'
                  - display.page.show: p70
            # info
            - if:
                condition:
                  lambda: return id(selected_index) == 8;
                then:
                  - lambda: |-
                      id(selected_sub_index) = 0;
                  - lambda: 'id(current_page) = "p80";'
                  - display.page.show: p80
            # monitoring
            - if:
                condition:
                  lambda: return id(selected_index) == 9;
                then:
                  - lambda: |-
                      id(selected_sub_index) = 0;
                  - lambda: 'id(current_page) = "p99_monitor";'
                  - display.page.show: p99_monitor



  - platform: touchscreen
    # globaler touch fÃ¼r back-button ansonsten feuern alle!!
    name: "Global Back Button"
    x_min: 100
    x_max: 140
    y_min: 0
    y_max: 50
    on_press:
      then:
        - lambda: |-
            auto now = millis();
            if (now - id(last_touch_ts) < 500) return;
            id(last_touch_ts) = now;

            if (id(current_page) == "p200000") {
              id(current_page) = "p20000";
              id(round_display).show_page(p20000);
            } 
            else if (id(current_page) == "p20000") {
              id(current_page) = "p2000";
              id(round_display).show_page(p2000);
            } 
            else if (id(current_page) == "p2000") {
              id(current_page) = "p00";
              id(round_display).show_page(p00);
            } 
            else if (id(current_page) == "p300000") {
              id(current_page) = "p30000";
              id(round_display).show_page(p30000);
            } 
            else if (id(current_page) == "p30000") {
              id(current_page) = "p3000";
              id(round_display).show_page(p3000);
            } 
            else if (id(current_page) == "p3000") {
              id(current_page) = "p00";
              id(round_display).show_page(p00);
            } 
            else if (id(current_page) == "p100000") {
              id(current_page) = "p10000";
              id(round_display).show_page(p10000);
            } 
            else if (id(current_page) == "p10000") {
              id(current_page) = "p1000";
              id(round_display).show_page(p1000);
            } 
            else if (id(current_page) == "p1000") {
              id(current_page) = "p00";
              id(round_display).show_page(p00);
            }
            else if (id(current_page) == "p70") {
              id(current_page) = "p00";
              id(round_display).show_page(p00);
            }
            else if (id(current_page) == "p80") {
              id(current_page) = "p00";
              id(round_display).show_page(p00);
            }
            else if (id(current_page) == "p99_monitor") {
              id(current_page) = "p00";
              id(round_display).show_page(p00);
            }

            id(script_play_sound).execute("${sound_menu_press}");
        - script.execute: reset_inactivity

  - platform: touchscreen
    name: "Raumhelligkeit verringern"
    internal: true
    page_id: p1000
    x_min: 10
    x_max: 50
    y_min: 100
    y_max: 140
    on_press:
      - script.execute: reset_inactivity
      - lambda: |-
          std::string topic = "m5dial/" + id(this_device) + "/set/room/light";
          std::string payload = "{ \"room\": \"" + id(selected_light_room) + "\", \"action\": \"brightness_minus\" }";
          // id(mqtt_client)->publish(topic, payload);
          id(smart_mqtt_publish).execute(topic, payload, "Raumhelligkeit",500);
          // ESP_LOGD("room brightness -", "MQTT: %s â†’ %s", topic.c_str(), payload.c_str());

  - platform: touchscreen
    name: "Raumhelligkeit erhÃ¶hen"
    internal: true
    page_id: p1000
    x_min: 190
    x_max: 240
    y_min: 100
    y_max: 140
    on_press:
      - script.execute: reset_inactivity
      - lambda: |-
          std::string topic = "m5dial/" + id(this_device) + "/set/room/light";
          std::string payload = "{ \"room\": \"" + id(selected_light_room) + "\", \"action\": \"brightness_plus\" }";
          // id(mqtt_client)->publish(topic, payload);
          id(smart_mqtt_publish).execute(topic, payload, "Raumhelligkeit",500);
          // ESP_LOGD("room brightness +", "MQTT: %s â†’ %s", topic.c_str(), payload.c_str());


  - platform: gpio
    name: Hold Button
    pin: GPIO46
    internal: True



select:
  - platform: template
    name: "Screensaver"
    id: screensaver_selector
    icon: "mdi:screen"
    optimistic: true
    options:
      - "matrix"
      - "breathing"
      - "analog clock 1"
      - "analog clock 2"
    initial_option: "analog clock 2"
    on_value:
      then:
        - lambda: |-
            id(screensaver_mode) = x;
            ESP_LOGD("screensaver", "Neuer Modus: %s", x.c_str());

  - platform: template
    name: "Soundauswahl"
    id: sound_selector
    icon: "mdi:bell-ring"
    optimistic: true
    options:
      - "Agado"
      - "Axel"
      - "Bolero"
      - "Bond"
      - "Borteus"
      - "Colonel"
      - "Dallas"
      - "Final"
      - "Flintstones"
      - "Fruit"
      - "Hawaii 5-O"
      - "Knight Rider"
      - "Let it be"
      - "Mission Impossible"
      - "Mozart"
      - "Muppet"
      - "New Year"
      - "Popcorn"
      - "Quofnight"
      - "Rudolf"
      - "Start Trek"
      - "Star Wars"
      - "Take on me"
      - "The A-Team"
      - "Titanic"
      - "Vanessa Mae"
      - "Waltons"
    initial_option: "The A-Team"
    restore_value: true
    on_value:
      then:
        - if:
            condition:
              lambda: return id(play_on_select_change);  # globaler Flag
            then:
        - script.execute:
            id: play_selected_sound
            rtttlsong: !lambda |-
              if (x == "Agado") return "${sound_agado}";
              if (x == "Axel") return "${sound_axel}";
              if (x == "Bolero") return "${sound_bolero}";
              if (x == "Bond") return "${sound_bond}";
              if (x == "Borteus") return "${sound_borteus}";
              if (x == "Colonel") return "${sound_colonel}";
              if (x == "Dallas") return "${sound_dallas}";
              if (x == "Final") return "${sound_final}";
              if (x == "Flintstones") return "${sound_flintstones}";
              if (x == "Fruit") return "${sound_fruit}";
              if (x == "Hawaii 5-O") return "${sound_hawaii}";
              if (x == "Knight Rider") return "${sound_knight}";
              if (x == "Let it be") return "${sound_letitbe}";
              if (x == "Mission Impossible") return "${sound_mission}";
              if (x == "Mozart") return "${sound_mozart}";
              if (x == "Muppet") return "${sound_muppet}";
              if (x == "New Year") return "${sound_newyear}";
              if (x == "Popcorn") return "${sound_popcorn}";
              if (x == "Quofnight") return "${sound_quofnigt}";
              if (x == "Rudolf") return "${sound_rudolf}";
              if (x == "Star Trek") return "${sound_startrek}";
              if (x == "Star Wars") return "${sound_starwars}";
              if (x == "Take on me") return "${sound_takeonme}";
              if (x == "The A-Team") return "${sound_theateam}";
              if (x == "Titanic") return "${sound_titanic}";
              if (x == "Vanessa Mae") return "${sound_vanessamae}";
              if (x == "Waltons") return "${sound_waltons}";
              return "";



button:
  - platform: template
    name: "Alarm"
    id: alarm_sound
    icon: "mdi:bell-ring"
    on_press:
    - rtttl.play: ${alarm_sound}
    - switch.turn_on: screen_saver
    - script.execute: reset_inactivity

color:
  - id: background_color
    hex: ${background_color}
  - id: icon_on
    hex: '00dd09'
  - id: icon_off
    hex: '000000'
  - id: icon_big_on
    hex: '24ff02'
  - id: icon_big_off
    hex: '000000'
  - id: dark_orange
    hex: 'd2750b'
  - id: light_orange
    hex: 'f9c699'
  - id: dark_green
    hex: '148506'
  - id: darkest_green
    hex: '106305'
  - id: shiny_green
    hex: '6bff59'
  - id: black
    hex: '000000'
  - id: white
    hex: 'ffffff'
  - id: red
    hex: 'ff0000'
  - id: dark_red
    hex: 'af0000'
  - id: darkest_red
    hex: '6f0000'
  - id: shiny_red
    hex: 'ee4b2b'
  - id: gray
    hex: 'cccccc'

font:
  - file: "gfonts://Space Grotesk"
    id: clock_time
    size: 40
    glyphs: ${allowed_characters}
  - file: "gfonts://Space Grotesk"
    id: secondary
    size: 18
    glyphs: ${allowed_characters}
## NEU
  - file: "gfonts://Roboto"
    id: font_small
    size: 16
    glyphs: " |!\"%()+=,-_.:Â°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ"

  - file: "gfonts://Roboto"
    id: font_tiny
    size: 10
    glyphs: " |!\"%()+=,-_.:Â°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ"

  - file: "gfonts://Roboto"
    id: font_middle
    size: 24
    glyphs: " |!\"%()+=,-_.:Â°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ"

  - file: "gfonts://Orbitron"
    id: font_matrix
    size: 24
    glyphs: " |!\"%()+=,-_.:Â°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

  - file: "gfonts://Roboto"
    id: font_clock
    size: 80
    glyphs: " |!\"%()+=,-_.:Â°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

globals:
  - id: this_device
    type: std::string
    restore_value: no
    initial_value: "\"\""  # leere Zeichenkette in AnfÃ¼hrungszeichen

  - id: global_activity_monitoring_events
    type: std::vector<std::tuple<std::string, std::string, float>>
    restore_value: no

  - id: matrix_drops
    type: std::vector<std::tuple<int, int, char>>
    restore_value: no

  - id: screensaver_mode
    type: std::string
    restore_value: no
    initial_value: "\"matrix\""

  - id: current_breath_color
    type: Color
    restore_value: no
    initial_value: 'Color(0, 0, 0)'  # Startfarbe z.â€¯B. schwarz

  - id: last_touch_ts
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: inactivity_time
    type: int
    restore_value: no
    initial_value: '0'
  - id: device
    type: int
    restore_value: no
    initial_value: '0'
# for dropdown
  - id: play_on_select_change
    type: bool
    restore_value: no
    initial_value: 'false'
# for current page
  - id: current_page
    type: std::string
    initial_value: "\"unknown\""
## NEU
  - id: selected_light_room
    type: std::string
    restore_value: no
    initial_value: ''
  - id: selected_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: selected_sub_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: selected_sub_sub_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: current_light_state
    type: bool
    restore_value: no
    initial_value: "false"
  - id: current_light_brightness
    type: int
    restore_value: no
    initial_value: '0'
  - id: current_light_color
    type: esphome::Color
    restore_value: no
    initial_value: "Color(255, 255, 255)"
    
  - id: selected_entity
    type: std::string
    restore_value: no
    initial_value: ''

  - id: mqtt_last_publish
    type: std::map<std::string, unsigned long>
    restore_value: no

## switch stuff
# als custom component definiert
#  - id: all_switches
#    type: std::vector<SwitchInfo>
#    restore_value: no
  - id: global_m5_switches_rooms
    type: std::string
    restore_value: false
    initial_value: '""'

  - id: global_m5_switches_by_room
    type: std::string
    restore_value: false
    initial_value: '""'

  - id: global_m5_switches_by_device
    type: std::string
    restore_value: false
    initial_value: '""'
  - id: selected_switch_entity
    type: std::string
    restore_value: no
    initial_value: ''

  - id: global_m5_tracking_ble
    type: std::string
    restore_value: false
    initial_value: '""'

  - id: selected_media
    type: std::string
    restore_value: no
    initial_value: ''

  - id: global_m5_media_rooms
    type: std::string
    restore_value: false
    initial_value: '""'

  - id: global_m5_media_by_room
    type: std::string
    restore_value: false
    initial_value: '""'

  
i2c:
  - id: internal_i2c
    sda: GPIO11
    scl: GPIO12
    scan: False
image:
  - file: ${background_image}
    id: background_image
    resize: 245x245
    type: RGB
    transparency: alpha_channel
  - file: ${background_image_saver}
    id: background_image_saver
    resize: 245x245
    type: RGB
    transparency: alpha_channel
  - file: ${background_image_saver_date_time}
    id: background_image_saver_date_time
    resize: 245x245
    type: RGB
    transparency: alpha_channel
  - file: mdi:home
    id: icon_home
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: mdi:plus-thick
    id: plus
    resize: 30x30
    type: BINARY
    transparency: chroma_key
  - file: mdi:minus-thick
    id: minus
    resize: 30x30
    type: BINARY
    transparency: chroma_key
  - file: mdi:home-map-marker
    id: vacuum_dock
    resize: 30x30
    type: BINARY
    transparency: chroma_key
  - file: mdi:play-box
    id: play_icon
    resize: 30x30
    type: BINARY
    transparency: chroma_key
  - file: mdi:pause-box
    id: pause_icon
    resize: 30x30
    type: BINARY
    transparency: chroma_key


  - file: ${pageicon_switch_on}
    id: pageicon_switch_on
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_switch_off}
    id: pageicon_switch_off
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_switch_una}
    id: pageicon_switch_una
    resize: 40x40
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_media_play}
    id: pageicon_media_play
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_media_stop}
    id: pageicon_media_stop
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_media_play_pause}
    id: pageicon_media_play_pause
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_media_volume_plus}
    id: pageicon_media_volume_plus
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_media_volume_minus}
    id: pageicon_media_volume_minus
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_media_volume_mute}
    id: pageicon_media_volume_mute
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_media_standby}
    id: pageicon_media_standby
    resize: 40x40
    type: BINARY
    transparency: chroma_key

    

  - file: ${pageicon_light_off}
    id: pageicon_light_off
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_light_on}
    id: pageicon_light_on
    resize: 40x40
    type: BINARY
    transparency: chroma_key


  - file: ${pageicon_plus}
    id: pageicon_plus
    resize: 40x40
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_minus}
    id: pageicon_minus
    resize: 40x40
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_back}
    id: pageicon_back
    resize: 40x40
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_00}
    id: pageicon_00
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_00}
    id: pageicon_00_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_10}
    id: pageicon_10
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_10}
    id: pageicon_10_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_20}
    id: pageicon_20
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_20}
    id: pageicon_20_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_30}
    id: pageicon_30
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_30}
    id: pageicon_30_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_40}
    id: pageicon_40
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_40}
    id: pageicon_40_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_50}
    id: pageicon_50
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_50}
    id: pageicon_50_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_60}
    id: pageicon_60
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_60}
    id: pageicon_60_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_70}
    id: pageicon_70
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_70}
    id: pageicon_70_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_80}
    id: pageicon_80
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_80}
    id: pageicon_80_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key

  - file: ${pageicon_90}
    id: pageicon_90
    resize: 40x40
    type: BINARY
    transparency: chroma_key
  - file: ${pageicon_90}
    id: pageicon_90_big
    resize: 100x100
    type: BINARY
    transparency: chroma_key




interval:
  - interval: 5s
    then:
      - lambda: |-
          if (id(current_page) == "p99_monitor") 
          {
            id(round_display).show_page(id(p99_monitor));
          }

  - interval: 1s
    then:
      - lambda: |-
          id(inactivity_time) += 1;

          // Seiten, bei denen kein automatischer Screensaver aktiviert wird
          std::vector<std::string> excluded_pages = {
            "locked_screen", "p99_monitor", "p1000", "p10000", "p100000"
          };

          bool allow_screen_saver = std::find(
            excluded_pages.begin(),
            excluded_pages.end(),
            id(current_page)
          ) == excluded_pages.end();

          if (id(auto_lock).state) {
            // Screensaver aktivieren, aber nicht auf ausgeschlossenen Seiten
            if (id(inactivity_time) > id(screen_saver_time).state && allow_screen_saver) {
              if (!id(screen_saver).state) {
                id(screen_saver).turn_on();
              }
            }

            // Display ausschalten nach Timeout
            if (id(inactivity_time) > id(auto_lock_time_out).state) {
              id(backlight_pwm).turn_off();
              id(syd_display).turn_off();
              id(screen_saver).turn_off();
            }

          } else {
            // Nur Screensaver, kein Ausschalten
            if (id(inactivity_time) > id(screen_saver_time).state && allow_screen_saver) {
              if (!id(screen_saver).state) {
                id(screen_saver).turn_on();
              }
            }
          }

  ## fÃ¼r Matrix screensaver
  - interval: 750ms
    then:
      - lambda: |-
          if (id(current_page) == "locked_screen") 
          {
            if (id(screensaver_mode) == "matrix") 
            {
              for (auto &m : id(matrix_drops)) {
                std::get<1>(m) += 24;
                if (std::get<1>(m) > 240) {
                  std::get<1>(m) = 0;
                  std::get<0>(m) = esp_random() % 240;
                }
                if ((esp_random() % 100) < 20) {
                  std::get<2>(m) = 'A' + (esp_random() % 26);
                }
              }
              // Hier KEIN show_page(), sondern einfach eine Display-Aktualisierung
              id(current_page) = "locked_screen";  // Seite ist aktiv
              id(round_display).update();  // Das erzwingt Redraw
            } 
            else if (id(screensaver_mode) == "breathing") 
            {
              static int phase = 0;
              phase = (phase + 1) % 100;
              float brightness = abs(phase - 50) / 50.0f;
              int val = int(brightness * 255.0f);
              id(current_breath_color) = Color(val, val, val);
            }
            else if (id(screensaver_mode) == "analog clock 1" || id(screensaver_mode) == "analog clock 2" ) 
            {
              static int phase = 0;
              phase = (phase + 1) % 600;
              float brightness = abs(phase - 50) / 50.0f;
              int val = int(brightness * 255.0f);
              id(current_breath_color) = Color(val, val, val);
            }
          }

  - interval: 100ms
    then:
      - lambda: |-
            if (id(current_page) == "locked_screen") 
            {
              if (id(screensaver_mode) == "breathing") 
              {
                static int brightness = 0;
                static int direction = 1;

                brightness += direction * 5;
                if (brightness >= 255) {
                  brightness = 255;
                  direction = -1;
                } else if (brightness <= 0) {
                  brightness = 0;
                  direction = 1;
                }
                id(current_page) = "locked_screen";  // Seite ist aktiv
                id(round_display).update();  // Das erzwingt Redraw
                id(current_breath_color) = Color(brightness, brightness, brightness);
              }
            }

light:
  - platform: monochromatic
    name: "Backlight"
    output: backlight_pwm
    id: backlight
    default_transition_length: 0s
    restore_mode: ALWAYS_ON
    internal: True
number:
  - platform: template
    name: "Auto Lock"
    id: auto_lock_time_out
    icon: "mdi:timer-sand"
    optimistic: true
    min_value: 20
    max_value: 300
    step: 10
    unit_of_measurement: "s"
    restore_value: true

  - platform: template
    name: "Screen Saver timeout"
    id: screen_saver_time
    icon: "mdi:screen-rotation-lock"
    optimistic: true
    min_value: 10
    max_value: 300
    step: 10
    unit_of_measurement: "s"
    restore_value: true


output:
  - platform: ledc
    pin: GPIO3
    id: buzzer
  - platform: ledc
    pin: GPIO9
    id: backlight_pwm
#rc522_i2c:
#  - i2c_id: internal_i2c
#    id: tag_reader
#    address: 0x28
#    on_tag:
#      then:
#        - rtttl.play: "success:d=24,o=5,b=100:c,g,b"
#        - homeassistant.tag_scanned: !lambda 'return x;'
rtttl:
  output: buzzer
sensor:
  - platform: rotary_encoder
    id: encoder
    pin_a: GPIO40
    pin_b: GPIO41
    on_clockwise:
      then:
        - script.execute: reset_inactivity
        - lambda: |-
            id(script_play_sound).execute("${sound_menu_clockwise}");
        - if:
            condition:
              display.is_displaying_page: p00
            then:
            - lambda: |-
                id(selected_index) += 1;
                if (id(selected_index) > 9) id(selected_index) = 0;
            - lambda: 'id(current_page) = "p00";'
            - display.page.show: p00

        ## Raeume lichter
        - if:
            condition:
              display.is_displaying_page: p1000
            then:
              - lambda: |-
                  std::string data = id(m5_list_lights).state;
                  id(selected_sub_index) += 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p1000";'
              - display.page.show: p1000
        ## Lichter im. Raum einzeln
        - if:
            condition:
              display.is_displaying_page: p10000
            then:
              - lambda: |-
                  std::string data = id(m5_list_lights).state;
                  id(selected_sub_sub_index) += 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p10000";'
              - display.page.show: p10000
        ## Raeume switches
        - if:
            condition:
              display.is_displaying_page: p2000
            then:
              - lambda: |-
                  id(selected_sub_index) += 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p2000";'
              - display.page.show: p2000
        ## devices im. Raum einzeln
        - if:
            condition:
              display.is_displaying_page: p20000
            then:
              - lambda: |-
                  id(selected_sub_sub_index) += 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p20000";'
              - display.page.show: p20000
        ## Raeume media
        - if:
            condition:
              display.is_displaying_page: p3000
            then:
              - lambda: |-
                  id(selected_sub_index) += 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p3000";'
              - display.page.show: p3000
        ## Player by ROOM media
        - if:
            condition:
              display.is_displaying_page: p30000
            then:
              - lambda: |-
                  id(selected_sub_sub_index) += 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p30000";'
              - display.page.show: p30000


        - script.execute: reset_inactivity


    on_anticlockwise:
      then:
        - script.execute: reset_inactivity
        - lambda: |-
            id(script_play_sound).execute("${sound_menu_cclockwise}");
        - if:
            condition:
              display.is_displaying_page: p00
            then:
            - lambda: |-
                id(selected_index) -= 1;
                if (id(selected_index) < 0 ) id(selected_index) = 9;
            - lambda: 'id(current_page) = "p00";'
            - display.page.show: p00
        ## Raeume lichter
        - if:
            condition:
              display.is_displaying_page: p1000
            then:
              - lambda: |-
                  id(selected_sub_index) -= 1;
              - lambda: 'id(current_page) = "p1000";'
              - display.page.show: p1000
        ## Lichter im. Raum einzeln
        - if:
            condition:
              display.is_displaying_page: p10000
            then:
              - lambda: |-
                  std::string data = id(m5_list_lights).state;
                  id(selected_sub_sub_index) -= 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p10000";'
              - display.page.show: p10000
        ## Raeume switches
        - if:
            condition:
              display.is_displaying_page: p2000
            then:
              - lambda: |-
                  id(selected_sub_index) -= 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p2000";'
              - display.page.show: p2000
        ## devices im. Raum einzeln
        - if:
            condition:
              display.is_displaying_page: p20000
            then:
              - lambda: |-
                  id(selected_sub_sub_index) -= 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p20000";'
              - display.page.show: p20000
        ## Raeume media
        - if:
            condition:
              display.is_displaying_page: p3000
            then:
              - lambda: |-
                  id(selected_sub_index) -= 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p3000";'
              - display.page.show: p3000
        ## Player by ROOM media
        - if:
            condition:
              display.is_displaying_page: p30000
            then:
              - lambda: |-
                  id(selected_sub_sub_index) -= 1; // keine Ã¼berprÃ¼fung hier - klappt nicht
              - lambda: 'id(current_page) = "p30000";'
              - display.page.show: p30000



        - script.execute: reset_inactivity



spi:
  id: spi_bus
  mosi_pin: GPIO5
  clk_pin: GPIO6
switch:
  - platform: template
    name: "Auto Lock"
    id: auto_lock
    icon: "mdi:lock-clock"
    optimistic: true
    restore_mode: 'restore_default_off'

  - platform: template
    name: "Display"
    id: syd_display
    icon: "mdi:fit-to-screen"
    optimistic: true
    restore_mode: 'always_on'
    on_turn_on:
      - light.turn_on:
          id: backlight
          brightness: 100%
      - script.execute: reset_inactivity

    on_turn_off:
      - light.turn_off: backlight
      - lambda: 'id(current_page) = "p00";'
      - display.page.show: p00
      - lambda: |-
          id(device) = 0;

  - platform: template
    name: "Screen Saver"
    id: screen_saver
    icon: "mdi:screen-rotation-lock"
    optimistic: true
    restore_mode: 'always_off'
    internal: true
    on_turn_on:
      - light.turn_on:
          id: backlight
          brightness: 30%
      - lambda: 'id(current_page) = "locked_screen";'
      - display.page.show: locked_screen
      - script.execute: init_matrix_drops
      - lambda: |-
          id(device) = 0;

  - platform: template
    name: "Menu Sounds"
    id: menu_sounds
    icon: "mdi:playlist-music"
    optimistic: true
    restore_mode: 'restore_default_on'

text_sensor:
## meine standard sensoren
  - platform: version
    hide_timestamp: true
    name: "ESPHome Version"
    entity_category: diagnostic
  - platform: wifi_info
    ip_address:
      name: "IP Address"
      icon: mdi:wifi
      entity_category: diagnostic
    ssid:
      name: "Connected SSID"
      icon: mdi:wifi-strength-2
      entity_category: diagnostic

## NEU ####################################
#  - platform: homeassistant
#    id: m5_list_lights
#    entity_id: input_text.m5_list_lights
#  - platform: homeassistant
#    id: m5_list_media
#    entity_id: input_text.m5_list_media
#  - platform: homeassistant
#    id: m5_list_aircon
#    entity_id: input_text.m5_list_aircon

  - platform: template
    id: m5_list_lights
    name: M5 Lights from MQTT
  - platform: template
    id: m5_list_switches
    name: M5 Lights from MQTT
  - platform: template
    id: m5_list_media
    name: M5 Media from MQTT
  - platform: template
    id: m5_list_aircon
    name: M5 Aircon from MQTT




time:
  # RTC
  - platform: pcf8563
    id: rtctime
    i2c_id: internal_i2c
    address: 0x51
    update_interval: never
  - platform: homeassistant
    id: esptime
    on_time_sync:
      then:
        - pcf8563.write_time:
touchscreen:
  - platform: ft5x06
    id: touchscreen_syd
    i2c_id: internal_i2c
    address: 0x38
    on_touch:
      - script.execute: reset_inactivity
      - lambda: |-
          int tx = touch.x;
          int ty = touch.y;

          // Nur auslÃ¶sen, wenn p10000 UND innerhalb des Helligkeitsbalkens
          //if (id(current_page) == "p10000" && tx >= 30 && tx <= 210 && ty >= 170 && ty <= 200) {
          if ( (id(current_page) == "p1000" || id(current_page) == "p10000" || id(current_page) == "p100000" ) && tx >= 30 && tx <= 210 && ty >= 170 && ty <= 200) 
          {
            int relative_x = tx - 30;
            int brightness = (relative_x * 255) / 180;
            id(current_light_brightness) = brightness;

            if (id(current_page) == "p100000") 
            {
              std::string topic = "m5dial/" + id(this_device) + "/set/light/" + id(selected_entity);
              std::string payload = "{ \"entity_id\": \"light." + id(selected_entity)+"\", \"state\": \"on\", \"brightness\": " + std::to_string(brightness) + "}";
              // id(mqtt_client)->publish(topic, payload);
              id(smart_mqtt_publish).execute(topic, payload, "SetLight",500);
              // ESP_LOGD("brightness_touch", "MQTT: %s â†’ %s", topic.c_str(), payload.c_str());
            }
            else if (id(current_page) == "p10000") 
            {
              std::string topic = "m5dial/" + id(this_device) + "/set/light/" + id(selected_entity);
              std::string payload = "{ \"entity_id\": \"light." + id(selected_entity)+"\", \"state\": \"on\", \"brightness\": " + std::to_string(brightness) + "}";
              // id(mqtt_client)->publish(topic, payload);
              id(smart_mqtt_publish).execute(topic, payload, "SetLight",500);
              // ESP_LOGD("brightness_touch", "MQTT: %s â†’ %s", topic.c_str(), payload.c_str());
            }
            else if (id(current_page) == "p1000") 
            {
              std::string room = id(selected_light_room);
              std::string topic = "m5dial/" + id(this_device) + "/set/room/light";
              std::string payload = "{ \"room\": \"" + room + "\", \"action\": \"brightness_absolut\", \"value\": " + std::to_string(brightness) + " }";
              // id(mqtt_client)->publish(topic, payload);
              id(smart_mqtt_publish).execute(topic, payload, "SetLight",500);
              // ESP_LOGD("touch", "Raumhelligkeit geÃ¤ndert (%s) â†’ %d", room.c_str(), brightness);
            }
          }


          // On/Off Button auf Seite p100000 (links oben)
          if (id(current_page) == "p100000" && tx >= 19 && tx <= 59 && ty >= 74 && ty <= 114) 
          {
            bool new_state = !id(current_light_state);  // Toggle state
            id(current_light_state) = new_state;

            std::string topic = "m5dial/" + id(this_device) + "/set/light/" + id(selected_entity);
            std::string payload = "{  \"entity_id\": \"light." + id(selected_entity)+"\", \"state\": \"" + (new_state ? "on" : "off") + "\" }";

            // id(mqtt_client)->publish(topic, payload);
            id(smart_mqtt_publish).execute(topic, payload, "SetLight",500);

            // ESP_LOGD("touch_onoff", "MQTT Toggle gesendet: %s â†’ %s", topic.c_str(), payload.c_str());
          }

          // Farbe auslesen  auf Seite p100000 und p1000 (Ã¼ber helligkeit)
          if ( (id(current_page) == "p100000" || id(current_page) == "p1000" ) && tx >= 30 && tx <= 210 && ty >= 140 && ty <= 160) 
          {
            int relative_x = tx - 30;
            float t = float(relative_x) / 179.0f;

            uint8_t r, g, b;
            if (t < 1.0f / 6.0f) {
              r = 255;
              g = uint8_t(t * 6.0f * 255.0f);
              b = 0;
            } else if (t < 2.0f / 6.0f) {
              r = uint8_t((2.0f / 6.0f - t) * 6.0f * 255.0f);
              g = 255;
              b = 0;
            } else if (t < 3.0f / 6.0f) {
              r = 0;
              g = 255;
              b = uint8_t((t - 2.0f / 6.0f) * 6.0f * 255.0f);
            } else if (t < 4.0f / 6.0f) {
              r = 0;
              g = uint8_t((4.0f / 6.0f - t) * 6.0f * 255.0f);
              b = 255;
            } else if (t < 5.0f / 6.0f) {
              r = uint8_t((t - 4.0f / 6.0f) * 6.0f * 255.0f);
              g = 0;
              b = 255;
            } else {
              r = 255;
              g = 0;
              b = uint8_t((1.0f - t) * 6.0f * 255.0f);
            }

            id(current_light_color) = Color(r, g, b);

            if (id(current_page) == "p100000")
            {
              std::string entity = id(selected_entity);
              std::string topic = "m5dial/" + id(this_device) + "/set/light/" + entity;
              std::string payload = "{ \"entity_id\": \"light." + entity + "\", \"state\": \"on\", \"color\": [" + std::to_string(r) + "," + std::to_string(g) + "," + std::to_string(b) + "] }";
              id(mqtt_client)->publish(topic, payload);
              ESP_LOGD("touch", "Farbe geÃ¤ndert fÃ¼r %s â†’ RGB(%d,%d,%d)", entity.c_str(), r, g, b);
            } 
            else if (id(current_page) == "p1000") 
            {
              // Alle eingeschalteten Lichter im Raum aktualisieren
              std::string room = id(selected_light_room);
              std::string topic = "m5dial/" + id(this_device) + "/set/room/light";
              std::string payload = "{ \"room\": \"" + room + "\", \"action\": \"color\", \"value\": [" + std::to_string(r) + "," + std::to_string(g) + "," + std::to_string(b) + "] }";
              id(mqtt_client)->publish(topic, payload);
              ESP_LOGD("touch", "Raumfarbe geÃ¤ndert (%s) â†’ RGB(%d,%d,%d)", room.c_str(), r, g, b);
            }

          }

          // Touch-Bereich auf Seite p20000
          if (id(current_page) == "p20000" ) 
          {
              // Button: Einschalten (Rechts â€“ Symbol rechts â†’ x â‰ˆ cx+60 â†’ ~180..220)
  
              const char* entity = id(selected_switch_entity).c_str();
              ESP_LOGD("touch", "POS (%s) x:%d y:%d ", entity , tx, ty );

              // it.image(cx - 24, cy + 10, id(pageicon_switch_on) , id(shiny_green) );
              // it.image(cx + 60, cy + 10, id(pageicon_switch_on) , id(dark_green) );
              // it.image(cx - 94, cy + 10, id(pageicon_switch_off) , id(shiny_red) );

              // Info Page of Device/Switch Power Consumption
              if (tx >= 80 && tx <= 160 && ty >= 80 && ty <= 120) 
              {
                id(current_page) = "p200000";
                id(round_display).show_page(id(p200000));
              }

              // Einschalten (rechts)
              if (tx >= 180 && tx <= 220 && ty >= 130 && ty <= 170) 
              {
                  std::string topic = "m5dial/" + id(this_device) + "/set/switch/" + entity;
                  std::string payload = std::string("{ \"entity_id\": \"") + entity + "\", \"state\": \"on\" }";
                  id(smart_mqtt_publish).execute(topic, payload, "Switch_set_on_off",500);
                  ESP_LOGD("touch", "POS (%s) x:%d y:%d ON!!!", entity , tx, ty );
              }

              // Ausschalten (links)
              if (tx >= 36 && tx <= 76 && ty >= 130 && ty <= 170) 
              {
                  std::string topic = "m5dial/" + id(this_device) + "/set/switch/" + entity;
                  std::string payload = std::string("{ \"entity_id\": \"") + entity + "\", \"state\": \"off\" }";
                  id(smart_mqtt_publish).execute(topic, payload, "Switch_set_on_off",500);
                  ESP_LOGD("touch", "POS (%s) x:%d y:%d OFF!!!", entity , tx, ty );
              }
            }


          // Touch-Bereich auf Seite p3000 und p30000  - media
          if (id(current_page) == "p3000" || id(current_page) == "p30000" ) 
          {
              // Button: Einschalten (Rechts â€“ Symbol rechts â†’ x â‰ˆ cx+60 â†’ ~180..220)
  
              const char* entity = id(selected_media).c_str();
              std::string group_player = "group";
              ESP_LOGD("touch", "POS (%s) x:%d y:%d ", entity , tx, ty );

              // it.image(cx - 60 - 40, cy + 20, id(pageicon_media_volume_minus), id(shiny_green));
              // it.image(cx + 60, cy + 20, id(pageicon_media_volume_plus), id(shiny_green));
              // it.image(cx - 20, cy + 20, id(pageicon_media_volume_mute), id(shiny_green));
              // it.image(cx - 20, cy + 70, id(pageicon_media_standby), id(shiny_green));  
              // it.image(cx - 60 - 40, cy - 30, id(pageicon_media_stop), id(shiny_green));
              // it.image(cx - 20, cy - 30, id(pageicon_media_play_pause), id(shiny_green));
              // it.image(cx + 60, cy - 30, id(pageicon_media_play), id(shiny_green));


              // Info Page of media_player einzeln
              if (tx >= 80 && tx <= 160 && ty >= 80 && ty <= 140 && id(current_page) == "p3000" ) 
              {
                id(current_page) = "p30000";
                id(round_display).show_page(id(p30000));
              }

              if ( id(current_page) == "p30000" ) 
              {
                group_player = "player";
              }


              // Volume down
              if (tx >= 40 && tx <= 80 && ty >= 140 && ty <= 180) 
              {
                  std::string topic = "m5dial/" + id(this_device) + "/set/media/volume/" + group_player + "/down/" +  entity;
                  std::string payload = std::string("{ \"entity_id\": \"") + entity + "\", \"state\": \"down\", \"group_player\": \"" + group_player + "\" }";
                  id(smart_mqtt_publish).execute(topic, payload, "Volume_set_up_down_mute_off",500);
                  ESP_LOGD("touch", "POS (%s) x:%d y:%d ON!!!", entity , tx, ty );
              }
              // Volume up
              if (tx >= 180 && tx <= 220 && ty >= 140 && ty <= 180) 
              {
                  std::string topic = "m5dial/" + id(this_device) + "/set/media/volume/" + group_player + "/up/" +  entity;
                  std::string payload = std::string("{ \"entity_id\": \"") + entity + "\", \"state\": \"up\", \"group_player\": \"" + group_player + "\" }";
                  id(smart_mqtt_publish).execute(topic, payload, "Volume_set_up_down_mute_off",500);
                  ESP_LOGD("touch", "POS (%s) x:%d y:%d ON!!!", entity , tx, ty );
              }
              // Volume mute
              if (tx >= 100 && tx <= 140 && ty >= 140 && ty <= 180) 
              {
                  std::string topic = "m5dial/" + id(this_device) + "/set/media/volume/" + group_player + "/mute/" +  entity;
                  std::string payload = std::string("{ \"entity_id\": \"") + entity + "\", \"state\": \"mute\", \"group_player\": \"" + group_player + "\" }";
                  id(smart_mqtt_publish).execute(topic, payload, "Volume_set_up_down_mute_off",500);
                  ESP_LOGD("touch", "POS (%s) x:%d y:%d ON!!!", entity , tx, ty );
              }

              // Players off
              if (tx >= 100 && tx <= 140 && ty >= 190 && ty <= 230) 
              {
                  std::string topic = "m5dial/" + id(this_device) + "/set/media/volume/" + group_player + "/off/" +  entity;
                  std::string payload = std::string("{ \"entity_id\": \"") + entity + "\", \"state\": \"off\", \"group_player\": \"" + group_player + "\" }";
                  id(smart_mqtt_publish).execute(topic, payload, "Volume_set_up_down_mute_off",500);
                  ESP_LOGD("touch", "POS (%s) x:%d y:%d ON!!!", entity , tx, ty );
              }

              // media stop
              if (tx >= 40 && tx <= 80 && ty >= 90 && ty <= 130 && id(current_page) == "p30000" ) 
              {
                  std::string topic = "m5dial/" + id(this_device) + "/set/media/volume/" + group_player + "/stop/" +  entity;
                  std::string payload = std::string("{ \"entity_id\": \"") + entity + "\", \"state\": \"stop\", \"group_player\": \"" + group_player + "\" }";
                  id(smart_mqtt_publish).execute(topic, payload, "Volume_set_up_down_mute_off",500);
                  ESP_LOGD("touch", "POS (%s) x:%d y:%d ON!!!", entity , tx, ty );
              }
              // media pause/play
              if (tx >= 100 && tx <= 140 && ty >= 90 && ty <= 130 && id(current_page) == "p30000" ) 
              {
                  std::string topic = "m5dial/" + id(this_device) + "/set/media/volume/" + group_player + "/pause_play/" +  entity;
                  std::string payload = std::string("{ \"entity_id\": \"") + entity + "\", \"state\": \"pause_play\", \"group_player\": \"" + group_player + "\" }";
                  id(smart_mqtt_publish).execute(topic, payload, "Volume_set_up_down_mute_off",500);
                  ESP_LOGD("touch", "POS (%s) x:%d y:%d ON!!!", entity , tx, ty );
              }
              // media play
              if (tx >= 180 && tx <= 220 && ty >= 90 && ty <= 130 && id(current_page) == "p30000" ) 
              {
                  std::string topic = "m5dial/" + id(this_device) + "/set/media/volume/" + group_player + "/play/" +  entity;
                  std::string payload = std::string("{ \"entity_id\": \"") + entity + "\", \"state\": \"play\", \"group_player\": \"" + group_player + "\" }";
                  id(smart_mqtt_publish).execute(topic, payload, "Volume_set_up_down_mute_off",500);
                  ESP_LOGD("touch", "POS (%s) x:%d y:%d ON!!!", entity , tx, ty );
              }

          }


display:
  - platform: ili9xxx
    id: round_display
    model: GC9A01A
    cs_pin: GPIO7
    reset_pin: GPIO8
    update_interval: 0.05s
    dc_pin: GPIO4
    invert_colors: true
    pages:

      - id: locked_screen
        lambda: |-
          if (id(screensaver_mode) == "matrix") 
          {
            it.fill(id(background_color));

            // Hintergrundbild
            it.image(0, 0, id(background_image_saver_date_time));

            // Matrix-Zeichen mit Nachleuchteffekt
            if ( 1 == 1 ) 
            {
              // Matrix-Zeichen mit Nachleuchteffekt
              for (auto &drop : id(matrix_drops)) 
              {
                int x = std::get<0>(drop);
                int y = std::get<1>(drop);
                char ch = std::get<2>(drop);


                // Nachleuchten oberhalb (sofern innerhalb Displaybereich)
                // Reihenfolge so, damit das oberste zeichen auf schÃ¶n leuchtet :-)
                if (y - 48 >= 0) {
                  it.printf(x, y - 16, id(font_matrix), darkest_green, "%c", ch);
                }
                if (y - 24 >= 0) {
                  it.printf(x, y - 8, id(font_matrix), dark_green, "%c", ch);
                }
                // Hauptzeichen
                it.printf(x, y, id(font_matrix), shiny_green, "%c", ch);


                // Bewegung nach unten
                y += 24;
                if (y > 240) {
                  y = 0;
                  ch = 'A' + (esp_random() % 26);
                  x = esp_random() % 240;
                }

                drop = std::make_tuple(x, y, ch);
              }
            }

            // Uhrzeit und Datum
            it.strftime(120, 26, id(clock_time), TextAlign::CENTER, "%H:%M", id(esptime).now());
            it.strftime(120, 217, id(secondary), TextAlign::CENTER, "%d/%m/%y", id(esptime).now());
          }
          else if (id(screensaver_mode) == "breathing") 
          {
            // Hintergrundbild
            it.image(0, 0, id(background_image_saver_date_time));

            // Hintergrund fÃ¼llen (Breathing)
            // it.fill(id(current_breath_color));

            // Atmender Kreis basierend auf Sekunden
            int seconds = id(esptime).now().second;

            // Kreisradius: von 20 bis 120 â†’ pulsiert jede 30s
            // float t = fmod(seconds, 30) / 30.0f;  // 0.0 â€“ 1.0
            // if (seconds % 60 >= 30) t = 1.0f - t;  // RÃ¼cklaufphase
            // // int radius = 20 + int(t * 100);  // 20 â€“ 120
            // int radius = 20 + int(t * 50);  // 20 â€“ 120

            float t = fmod(seconds, 15) / 7.5f;  // 0.0 â€“ 2.0
            if (t > 1.0f) t = 2.0f - t;          // RÃ¼cklaufphase bei 7.5sâ€“15s
            int radius = 20 + int(t * 50);       // Radius von 20 bis 70 (20 + 50)

            // Farbe ebenfalls abhÃ¤ngig von t (RegenbogenÃ¤hnlich)
            uint8_t r = uint8_t(255 * t);
            uint8_t g = uint8_t(255 * (1.0f - t));
            uint8_t b = uint8_t(128 + 127 * sinf(t * 2 * 3.1415f));  // 128â€“255 oszillierend

            Color c = Color(r, g, b);

            // Hintergrund in dunkler Farbe
            // it.fill(Color(0, 0, 0));

            // Kreiseffekt (nur Rahmen)
            // it.circle(120, 120, radius, c );
            // it.circle(120, 120, radius - 1, c ); // id(current_breath_color)
            // it.circle(120, 120, radius - 2, c );
            it.filled_circle(120, 120, radius, c);

            // optional: mit gefÃ¼lltem Kreis
            // it.filled_circle(120, 120, radius, c);

            // Uhrzeit und Datum
            it.strftime(120, 26, id(clock_time), TextAlign::CENTER, "%H:%M", id(esptime).now());
            it.strftime(120, 217, id(secondary), TextAlign::CENTER, "%d/%m/%y", id(esptime).now());
          }
          
          else if (id(screensaver_mode) == "analog clock 1") 
          {
            // Hintergrundbild
            it.image(0, 0, id(background_image_saver_date_time));

            const int cx = 120;
            const int cy = 120;
            const int radius = 100;

            auto now = id(esptime).now();

            // Stundenwinkel
            float hour_angle = (now.hour % 12 + now.minute / 60.0f) * 30.0f;  // 360Â° / 12h
            float hour_rad = hour_angle * M_PI / 180.0f;
            int hx = cx + int(50 * sin(hour_rad));
            int hy = cy - int(50 * cos(hour_rad));
            it.line(cx, cy, hx, hy, shiny_green);

            // Minutenwinkel
            float minute_angle = (now.minute + now.second / 60.0f) * 6.0f;  // 360Â° / 60min
            float min_rad = minute_angle * M_PI / 180.0f;
            int mx = cx + int(80 * sin(min_rad));
            int my = cy - int(80 * cos(min_rad));
            it.line(cx, cy, mx, my, shiny_green);

            // Sekundenwinkel
            float sec_angle = now.second * 6.0f;  // 360Â° / 60s
            float sec_rad = sec_angle * M_PI / 180.0f;
            int sx = cx + int(117 * sin(sec_rad));
            int sy = cy - int(117 * cos(sec_rad));
            it.line(cx, cy, sx, sy, white );
            it.filled_circle(sx, sy, 3, white);

            // Mittelpunkt
            it.filled_circle(cx, cy, 4, shiny_green);

            // Uhrzeit und Datum
            it.strftime(120, 26, id(clock_time), TextAlign::CENTER, "%H:%M", id(esptime).now());
            it.strftime(120, 217, id(secondary), TextAlign::CENTER, "%d/%m/%y", id(esptime).now());
          }
          else if (id(screensaver_mode) == "analog clock 2") 
          {
            // Hintergrundbild
            it.image(0, 0, id(background_image_saver));

            const int cx = 120;
            const int cy = 120;
            const int radius = 100;

            auto now = id(esptime).now();

            // Zeit formatieren mit blinkendem Doppelpunkt
            static bool show_colon = true;
            static int last_second = -1;
            if (now.second != last_second) {
              last_second = now.second;
              show_colon = !show_colon;
            }

            char time_string[6];
            snprintf(time_string, sizeof(time_string), show_colon ? "%02d:%02d" : "%02d %02d", now.hour, now.minute);

            // Sekundenkreis â†’ 30 Sekunden = 360Â°
            float sec_angle = (now.second % 60) * 6.0f;  // 12Â° pro Sekunde
            float sec_rad = sec_angle * M_PI / 180.0f;
            int loc_radius = 100;
            int sx = cx + int(loc_radius * sin(sec_rad));
            int sy = cy - int(loc_radius * cos(sec_rad));

            // Uhrzeit zentriert anzeigen
            it.printf(cx, cy - 00, id(font_clock), shiny_green, TextAlign::CENTER, "%s", time_string);

            // Kleiner Punkt als Sekundenanzeige
            it.filled_circle(sx, sy, 20, black);
            it.filled_circle(sx, sy, 14, shiny_green );
            it.filled_circle(sx, sy, 7, shiny_red );
          }

      - id: p70
        lambda: |-
          it.fill(black);
          // Mittelpunkt des Displays
          const int cx = 120;
          const int cy = 120;
          const int max_y = 200;

          int cys = 30; // achtung nicht als konstante defiinieren

          // Home-Button oben
          it.image(100, 15, id(pageicon_back), id(shiny_green));
          it.image(cx - 50, cy - 50, id(pageicon_70_big), id(darkest_green)); 

          std::string topic = "m5dial/" + id(this_device) + "/request/tracking/ble";
          std::string payload = "{}";
          // id(mqtt_client)->publish(topic, payload);
          id(smart_mqtt_publish).execute(topic, payload, "RequestTrackingBLE",5000);

          // Zeit anzeigen
          auto now = id(esptime).now();
          it.strftime(cx, 20, id(font_small), id(dark_green), TextAlign::CENTER, "%H:%M:%S", now);

          // JSON-Daten einmalig deserialisieren
          DynamicJsonDocument doc(8192);  // genug Platz fÃ¼r viele EintrÃ¤ge
          
          // it.print(10, 10, id(font_small), id(shiny_red), "Start render...");

          DeserializationError err = deserializeJson(doc, id(global_m5_tracking_ble).c_str());
          if (err) {
            // it.print(10, 30, id(font_small), id(dark_red), "JSON error:");
            // it.print(50, 50, id(font_small), id(shiny_red), err.c_str());
            return;
          }


          // std::string raw = id(global_m5_tracking_ble).c_str();
          // it.print(10, 20, id(font_small), id(dark_green), raw.c_str());

          // durch alle Objekte im Array gehen
          for (JsonObject e : doc.as<JsonArray>()) {
            if (!e.containsKey("s_x") || !e.containsKey("s_y") || !e.containsKey("type")) continue;

            int sx = e["s_x"];
            int sy = e["s_y"];
            sy = max_y - sy;

            int x = cx - 100 + sx;
            int y = cy - 100 + sy;

            std::string typ = e["type"].as<std::string>();
            Color color = id(shiny_green);
            if (typ == "known") color = id(shiny_red);
            else if (typ == "estimated") color = id(dark_red);

            it.filled_circle(x, y, 3, color);

            if (e.containsKey("id")) {
              std::string label = e["id"].as<std::string>();
              it.print(x + 4, y - 4, id(font_tiny), color, TextAlign::TOP_LEFT, label.c_str());
            }
          }



      - id: p80
        lambda: |-
          it.fill(black);
          // Mittelpunkt des Displays
          const int cx = 120;
          const int cy = 120;
          int cys = 30; // achtung nicht als konstante defiinieren

          // Home-Button oben
          it.image(100, 15, id(pageicon_back), id(shiny_green));
          it.image(cx - 50, cy - 50, id(pageicon_80_big), id(darkest_green)); 

          it.print(cx, cys, id(font_small), TextAlign::CENTER, "GerÃ¤testatus");
          cys += 20;
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "Name: %s", id(this_device).c_str());
          cys += 15;
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "IP: %s", WiFi.localIP().toString().c_str());
          cys += 15;
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "Subnet: %s", WiFi.subnetMask().toString().c_str());
          cys += 15;
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "Gateway: %s", WiFi.gatewayIP().toString().c_str());
          cys += 15;
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "RSSI: %d dBm", WiFi.RSSI());
          cys += 15;
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "MAC: %s", WiFi.macAddress().c_str());
          cys += 15;

          // Erweiterte Infos
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "Build: %s %s", __DATE__, __TIME__);
          cys += 15;
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "Uptime: %.1f min", (millis() / 60000.0));
          cys += 15;
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "Heap: %u bytes", ESP.getFreeHeap());
          cys += 15;
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "CPU MHz: %u", ESP.getCpuFreqMHz());
          cys += 15;
          // ESP.getChipId geht nicht mit / Falls du platform: ESP32 verwendest, funktioniert ESP.getChipId() nicht direkt. 
          // it.printf(cx, cys, id(font_small), TextAlign::CENTER, "ESP-ID: %08X", ESP.getChipId());
          // Chip-ID (ESP32): 12-stellig, hexadezimal
          uint64_t chipid = ESP.getEfuseMac();
          it.printf(cx, cys, id(font_small), TextAlign::CENTER, "ESP-ID: %012llX", chipid);
          cys += 15;

      - id: p99_monitor
        lambda: |-
          // Mittelpunkt des Displays
          const int cx = 120;
          const int cy = 120;
          const int loc_radius = 100;

          it.fill(black);

          // Aktuelle Zeit
          auto now = id(esptime).now();
          int sekunde = id(esptime).now().second;

          // Zeit oben
          it.strftime(cx, 20, id(font_small), id(dark_green), TextAlign::CENTER, "%H:%M:%S", now );



          // Home-Button oben
          it.image(100, 15, id(pageicon_back), id(shiny_green));

          if (sekunde % 2 == 0) 
          {
            it.image(cx - 50, cy - 50, id(pageicon_90_big), id(darkest_green)); 
          } else {
            it.image(cx - 50, cy - 50, id(pageicon_90_big), id(darkest_red)); 
          }

          // ZÃ¤hle Ereignisse pro Typ
          auto now_stamp = id(esptime).now().timestamp;
          std::map<std::string, int> type_counts;
          for (auto &e : id(global_activity_monitoring_events)) 
          {
            std::string typ = std::get<0>(e);
            float t = std::get<2>(e);
            if ((now_stamp - t) <= 300) {
              type_counts[typ]++;
            }
          }

          // code for no activity
          int num_types = type_counts.size();
          if (num_types == 0) 
          {
            if (sekunde % 2 == 0) 
            {
              it.print(cx, cy, id(font_middle),id(dark_red), TextAlign::CENTER, "no activity");
            } else {
              it.print(cx, cy, id(font_middle),id(dark_green), TextAlign::CENTER, "no activity");
            }
            return;
          }


          const int total_height = 120;
          const int bar_width = 180;
          const int bar_spacing = 4;
          const int max_events = 10;
          const int bar_left = cx - bar_width / 2;
          int bar_h = std::max(6, (total_height - (num_types - 1) * bar_spacing) / num_types);
          int bar_y = cy - total_height / 2;


          for (auto &pair : type_counts) {
            std::string typ = pair.first;
            int count = pair.second;
            int bar_len = std::min(count * 20, bar_width);

            // Farbschema: von GrÃ¼n â†’ Gelb â†’ Rot
            uint8_t r = 0, g = 255, b = 0;
            if (count <= 6) {
              float t = float(count) / 6.0f;
              r = uint8_t(255.0f * t);
              g = 255;
            } else {
              float t = float(count - 6) / float(max_events - 6);
              r = 255;
              g = uint8_t(255.0f * (1.0f - t));
            }

            // Balken zeichnen
            it.rectangle(bar_left, bar_y, bar_width, bar_h, darkest_green);
            it.filled_rectangle(bar_left, bar_y, bar_len, bar_h, Color(r, g, b));

            // Typ und ZÃ¤hler
            it.printf(bar_left - 5, bar_y + bar_h / 2, id(font_small), TextAlign::RIGHT, "%s", typ.c_str());
            it.printf(bar_left + bar_width + 5, bar_y + bar_h / 2, id(font_small), TextAlign::LEFT, "%d", count);

            bar_y += bar_h + bar_spacing;
          }


          // START - Funktion zur Kreisposition ###########################
          auto pos = [=](int s, int &x, int &y) 
          {
            float angle = s * 6.0f * M_PI / 180.0f;  // 6Â° pro Sekunde
            x = cx + int(loc_radius * sin(angle));
            y = cy - int(loc_radius * cos(angle));
          };

          // Nachleuchten: 2 Sekunden frÃ¼her â†’ darkest_green
          int sx2, sy2;
          pos((sekunde - 2 + 60) % 60, sx2, sy2);
          it.filled_circle(sx2, sy2, 14, darkest_green);

          // Nachleuchten: 1 Sekunde frÃ¼her â†’ dark_green
          int sx1, sy1;
          pos((sekunde - 1 + 60) % 60, sx1, sy1);
          it.filled_circle(sx1, sy1, 14, dark_green);

          // Hauptpunkt (aktuelle Sekunde)
          int sx0, sy0;
          pos(sekunde, sx0, sy0);
          it.filled_circle(sx0, sy0, 20, black);

          if (now.second % 2 == 0) 
          {
            it.filled_circle(sx0, sy0, 14, shiny_green);
            it.filled_circle(sx0, sy0, 7, shiny_red);
          } else {
            it.filled_circle(sx0, sy0, 14, shiny_red);
            it.filled_circle(sx0, sy0, 7, shiny_green);
          }
          // ENDE - Funktion zur Kreisposition ###########################


          // code for ACTIVITY
          if (num_types > 0) 
          {
            if (sekunde % 2 == 0) 
            {
              it.print(cx, cy, id(font_middle),id(shiny_red), TextAlign::CENTER, "ACTIVITY");
            } else {
              it.print(cx, cy, id(font_middle),id(shiny_green), TextAlign::CENTER, "ACTIVITY");
            }
          }


      - id: p00
        lambda: |-
          // Hintergrund lÃ¶schen
          it.fill(black);

          // Kreis-Mittelpunkt
          const int cx = 120;
          const int cy = 120;
          const int r = 85;


          // Texte fÃ¼r Buttons im Uhrzeigersinn
          std::vector<std::string> labels = {
            "Home", "Licht", "Media", "Klima",
            "Frei1", "Frei2", "Frei3", "Frei4", "Frei5", "Frei6"
          };

          // Zeichne kreisfÃ¶rmige Button-Beschriftungen
          for (int i = 0; i < labels.size(); i++) {
            float angle = i * 36.0f * 3.14159f / 180.0f;
            int x = cx + int(r * sin(angle));
            int y = cy - int(r * cos(angle));
            
             switch(i) 
             {
                case 0: 
                  it.image(x - 20, y - 20, id(pageicon_00)  , id(dark_green) ); 
                  break;
                case 1: 
                  it.image(x - 20, y - 20, id(pageicon_10)  , id(dark_green) ); 
                  break;
                case 2: 
                  it.image(x - 20, y - 20, id(pageicon_20)  , id(dark_green) ); 
                  break;
                case 3: 
                  it.image(x - 20, y - 20, id(pageicon_30)  , id(dark_green) ); 
                  break;
                case 4: 
                  it.image(x - 20, y - 20, id(pageicon_40)  , id(dark_green) ); 
                  break;
                case 5: 
                  it.image(x - 20, y - 20, id(pageicon_50)  , id(dark_green) ); 
                  break;
                case 6: 
                  it.image(x - 20, y - 20, id(pageicon_60)  , id(dark_green) ); 
                  break;
                case 7: 
                  it.image(x - 20, y - 20, id(pageicon_70)  , id(dark_green) ); 
                  break;
                case 8: 
                  it.image(x - 20, y - 20, id(pageicon_80)  , id(dark_green) ); 
                  break;
                case 9: 
                  it.image(x - 20, y - 20, id(pageicon_90)  , id(dark_green) ); 
                  break;
             }


            if (i == id(selected_index)) 
            {
              // it.print(x, y, id(font_small), shiny_green, TextAlign::CENTER, labels[i].c_str());
              // it.print(cx, cy, id(font_middle), shiny_green, TextAlign::CENTER,  labels[i].c_str() );
              
              switch(i) {
                case 0: 
                    it.image(x - 20, y - 20, id(pageicon_00)  , id(shiny_green) ); 
                    it.image(cx - 50, cy - 50, id(pageicon_00_big)  , id(shiny_green) ); 
                    break;
                case 1: 
                  it.image(x - 20, y - 20, id(pageicon_10)  , id(shiny_green) ); 
                  it.image(cx - 50, cy - 50, id(pageicon_10_big)  , id(shiny_green) ); 
                  break;
                case 2: 
                  it.image(x - 20, y - 20, id(pageicon_20)  , id(shiny_green) ); 
                  it.image(cx - 50, cy - 50, id(pageicon_20_big)  , id(shiny_green) ); 
                  break;
                case 3: 
                  it.image(x - 20, y - 20, id(pageicon_30)  , id(shiny_green) ); 
                  it.image(cx - 50, cy - 50, id(pageicon_30_big)  , id(shiny_green) ); 
                  break;
                case 4: 
                  it.image(x - 20, y - 20, id(pageicon_40)  , id(shiny_green) ); 
                  it.image(cx - 50, cy - 50, id(pageicon_40_big)  , id(shiny_green) ); 
                  break;
                case 5: 
                  it.image(x - 20, y - 20, id(pageicon_50)  , id(shiny_green) ); 
                  it.image(cx - 50, cy - 50, id(pageicon_50_big)  , id(shiny_green) ); 
                  break;
                case 6: 
                  it.image(x - 20, y - 20, id(pageicon_60)  , id(shiny_green) ); 
                  it.image(cx - 50, cy - 50, id(pageicon_60_big)  , id(shiny_green) ); 
                  break;
                case 7: 
                  it.image(x - 20, y - 20, id(pageicon_70)  , id(shiny_green) ); 
                  it.image(cx - 50, cy - 50, id(pageicon_70_big)  , id(shiny_green) ); 
                  break;
                case 8: 
                  it.image(x - 20, y - 20, id(pageicon_80)  , id(shiny_green) ); 
                  it.image(cx - 50, cy - 50, id(pageicon_80_big)  , id(shiny_green) ); 
                  break;
                case 9: 
                  it.image(x - 20, y - 20, id(pageicon_90)  , id(shiny_green) ); 
                  it.image(cx - 50, cy - 50, id(pageicon_90_big)  , id(shiny_green) ); 
                  break;
              }
            } 
          }


      # Raumselektion licht
      - id: p1000
        lambda: |-
          it.fill(black);
          const int cx = 120;
          const int cy = 120;
          Color selected_color = id(current_light_color);

          // Home-Button oben
          it.image(100, 15, id(pageicon_00), id(shiny_green));
          it.image(cx - 50, cy - 50, id(pageicon_10_big), id(darkest_green)); 

          // Zeichne Plus und Minus-Icon
          it.image( 10, 120 - 20, id(pageicon_minus), shiny_green);
          it.image(240 - 50, 120 - 20, id(pageicon_plus), shiny_green);

          std::string data = id(m5_list_lights).state;
          std::vector<std::string> rooms;
          size_t start = 0;
          size_t end;

          while ((end = data.find("Â§", start)) != std::string::npos) {
            std::string block = data.substr(start, end - start);
            size_t sep = block.find(":");
            if (sep != std::string::npos) {
              std::string room = block.substr(0, sep);
              room.erase(0, room.find_first_not_of(" \t\n\rÂ§:"));
              room.erase(room.find_last_not_of(" \t\n\rÂ§:") + 1);
              rooms.push_back(room);
            }
            start = end + 1;
          }

          // Letzter Block nach dem letzten "Â§"
          if (start < data.length()) {
            std::string block = data.substr(start);
            size_t sep = block.find(":");
            if (sep != std::string::npos) {
              std::string room = block.substr(0, sep);
              room.erase(0, room.find_first_not_of(" \t\n\rÂ§:"));
              room.erase(room.find_last_not_of(" \t\n\rÂ§:") + 1);
              rooms.push_back(room);
            }
          }

          // Kein Raum gefunden?
          if (rooms.empty()) {
            it.print(cx, cy, id(font_middle), TextAlign::CENTER, "Keine RÃ¤ume");
            return;
          }

          // Raum auswÃ¤hlen per Subindex
          int room_index = id(selected_sub_index);
          if (room_index < 0) room_index = 0;
          if (room_index >= rooms.size()) room_index = rooms.size() - 1;

          std::string current_room = rooms[room_index];
          id(selected_light_room) = current_room;
          // ESP_LOGD("p1000", "Zeige Raum-Index %d: %s", room_index, current_room.c_str());


          // Raumname zentriert anzeigen
          it.print(cx, cy - 40, id(font_middle), shiny_green, TextAlign::CENTER, current_room.c_str());

          // MQTT Request senden
          // std::string topic = "m5dial/" + id(this_device) + "/get/room/light/" + current_room;
          // id(mqtt_client)->publish(topic, "status");
          id(smart_mqtt_publish).execute("m5dial/" + id(this_device) + "/get/room/light/" + current_room, "status", "GetLight",500);

          // Balken fÃ¼r Helligkeit
          int brightness = id(current_light_brightness);  // 0â€“255
          int filled_bars = (brightness + 25) / 26;  // ca. 0â€“10 Balken

          for (int i = 0; i < 10; i++) 
          {
            int bx = 30 + i * 18;
            int by = cy + 50;
            it.rectangle(bx, by, 12, 20, darkest_green);
            if (i < filled_bars) 
            {
              it.filled_rectangle(bx + 1, by + 1, 10, 18, shiny_green);
            }
          }


          // Farbverlauf-Balken zeichnen (RGB)
          const int bar_x = 30;
          const int bar_y = 140;
          const int bar_w = 180;
          const int bar_h = 20;

          for (int x = 0; x < bar_w; x++) {
            float t = float(x) / float(bar_w - 1);
            uint8_t r, g, b;
            if (t < 1.0 / 6.0) {
              r = 255;
              g = uint8_t(t * 6.0f * 255.0f);
              b = 0;
            } else if (t < 2.0 / 6.0) {
              r = uint8_t((2.0f / 6.0f - t) * 6.0f * 255.0f);
              g = 255;
              b = 0;
            } else if (t < 3.0 / 6.0) {
              r = 0;
              g = 255;
              b = uint8_t((t - 2.0f / 6.0f) * 6.0f * 255.0f);
            } else if (t < 4.0 / 6.0) {
              r = 0;
              g = uint8_t((4.0f / 6.0f - t) * 6.0f * 255.0f);
              b = 255;
            } else if (t < 5.0 / 6.0) {
              r = uint8_t((t - 4.0f / 6.0f) * 6.0f * 255.0f);
              g = 0;
              b = 255;
            } else {
              r = 255;
              g = 0;
              b = uint8_t((1.0f - t) * 6.0f * 255.0f);
            }

            for (int y = 0; y < bar_h; y++) {
              it.draw_pixel_at(bar_x + x, bar_y + y, Color(r, g, b));
            }

            int delta = abs(int(r) - selected_color.r) + abs(int(g) - selected_color.g) + abs(int(b) - selected_color.b);
            if (delta < 40) {  // 30 ist die maximale Toleranz
              for (int y = -8; y < bar_h+8; y++) 
              {
                it.draw_pixel_at(bar_x + x, bar_y + y, Color(r, g, b));
              }
            }
            
          }

          // Hinweis
          it.printf(cx, 220, id(font_small), darkest_green, TextAlign::CENTER, "OK fÃ¼r GerÃ¤te");


      # lichter vom Raum selektion 
      - id: p10000
        lambda: |-
          it.fill(black);
          const int cx = 120;
          const int cy = 120;

          // Home-Button oben
          it.image(100, 15, id(pageicon_back), id(shiny_green));
          it.image(cx - 50, cy - 50, id(pageicon_10_big), id(darkest_green)); 


          std::string data = id(m5_list_lights).state;
          std::vector<std::string> room_blocks;
          size_t start = 0;
          size_t end;

          while ((end = data.find("\u00a7", start)) != std::string::npos) {
            room_blocks.push_back(data.substr(start, end - start));
            start = end + 1;
          }
          if (start < data.length()) {
            room_blocks.push_back(data.substr(start));
          }

          if (id(selected_sub_index) >= room_blocks.size()) return;
          std::string block = room_blocks[id(selected_sub_index)];
          size_t sep = block.find(":");
          if (sep == std::string::npos) return;

          std::string room_name = block.substr(0, sep);
          std::string devices_raw = block.substr(sep + 1);

          std::vector<std::string> devices;
          start = 0;
          while ((end = devices_raw.find(",", start)) != std::string::npos) {
            devices.push_back(devices_raw.substr(start, end - start));
            start = end + 1;
          }
          if (start < devices_raw.length()) {
            devices.push_back(devices_raw.substr(start));
          }

          if (devices.empty()) {
            it.print(cx, cy, id(font_middle), TextAlign::CENTER, "Keine GerÃ¤te");
            return;
          }

          int idx = id(selected_sub_sub_index);
          if (idx < 0) idx = 0;
          if (idx >= devices.size()) idx = devices.size() - 1;

          std::string device_line = devices[idx];
          size_t name_sep = device_line.find("|");
          std::string label = name_sep != std::string::npos ? device_line.substr(0, name_sep) : device_line;
          // Aus device_line extrahiert
          std::string entity = name_sep != std::string::npos ? device_line.substr(name_sep + 1) : "unknown";


          // Optional speichern
          id(selected_entity) = entity;

          // MQTT Request senden
          // std::string topic = "m5dial/" + id(this_device) + "/get/light/" + entity;
          // id(mqtt_client)->publish(topic, "status");
          id(smart_mqtt_publish).execute("m5dial/" + id(this_device) + "/get/light/" + label, "status", "GetLight",500);

          // Licht von Raum zentriert anzeigen
          it.print(cx, cy - 40, id(font_middle), shiny_green, TextAlign::CENTER,  label.c_str());


          // Balken fÃ¼r Helligkeit
          int brightness = id(current_light_brightness);  // 0â€“255
          int filled_bars = (brightness + 25) / 26;  // ca. 0â€“10 Balken

          for (int i = 0; i < 10; i++) 
          {
            int bx = 30 + i * 18;
            int by = cy + 50;
            it.rectangle(bx, by, 12, 20, darkest_green);
            if (i < filled_bars) 
            {
              it.filled_rectangle(bx + 1, by + 1, 10, 18, shiny_green);
            }
          }


          // Raumname Ã¼ber ok
          it.printf(cx, 201, id(font_small), darkest_green, TextAlign::CENTER, "%s", room_name.c_str());
          //  ok
          it.printf(cx, 220, id(font_small), darkest_green, TextAlign::CENTER, "OK: zur Steuerung");


      - id: p100000
        lambda: |-
          it.fill(black);
          const int cx = 120;
          const int cy = 120;
          Color selected_color = id(current_light_color);


          // Home-Button oben
          it.image(100, 15, id(pageicon_back), id(shiny_green));

          // Hole Daten aus input_text
          std::string data = id(m5_list_lights).state;
          std::string selected_room = id(selected_light_room);
          int sub_index = id(selected_sub_sub_index);

          // Raum finden
          size_t room_start = data.find(selected_room + ":");
          if (room_start == std::string::npos) {
            it.print(cx, cy, id(font_middle), red, TextAlign::CENTER, "Kein Raum");
            return;
          }

          size_t room_end = data.find("Â§", room_start);
          std::string room_block = data.substr(room_start, room_end - room_start);

          size_t sep = room_block.find(":");
          if (sep == std::string::npos) return;

          std::string devices_raw = room_block.substr(sep + 1);

          std::vector<std::string> devices;
          size_t start = 0;
          size_t end;
          while ((end = devices_raw.find(",", start)) != std::string::npos) {
            devices.push_back(devices_raw.substr(start, end - start));
            start = end + 1;
          }
          if (start < devices_raw.length()) {
            devices.push_back(devices_raw.substr(start));
          }

          // Anzeige Lichtstatus
          if (id(current_light_state)) 
          {
            it.image(cx - 50, cy - 50, id(pageicon_10_big)  , id(darkest_green) ); 
            it.image(39 - 20, 94 - 20, id(pageicon_light_off), shiny_red);
          } 
          else 
          {
            it.image(cx - 50, cy - 50, id(pageicon_10_big)  , id(darkest_red) ); 
            it.image(39 - 20, 94 - 20, id(pageicon_light_on), shiny_green);
          }


          if (devices.empty()) {
            it.print(cx, cy, id(font_middle), red, TextAlign::CENTER, "Keine GerÃ¤te");
            return;
          }

          if (sub_index < 0) sub_index = 0;
          if (sub_index >= devices.size()) sub_index = devices.size() - 1;

          std::string device_line = devices[sub_index];
          size_t name_sep = device_line.find("|");
          std::string label = name_sep != std::string::npos ? device_line.substr(0, name_sep) : device_line;

          // MQTT Request senden
          // std::string topic = "m5dial/" + id(this_device) + "/get/light/" + entity;
          // id(mqtt_client)->publish(topic, "status");
          id(smart_mqtt_publish).execute("m5dial/" + id(this_device) + "/get/light/" + label, "status", "GetLight",500);


          // Anzeige Helligkeit (Balken)
          int brightness = id(current_light_brightness);
          int filled = (brightness * 180) / 255;

          for (int i = 0; i < 10; i++) {
            int bx = 30 + i * 18;
            int by = cy + 50;
            it.rectangle(bx, by, 12, 20, darkest_green);
            if (i * 18 < filled) {
              it.filled_rectangle(bx + 1, by + 1, 10, 18, shiny_green);
            }
          }

          it.printf(cx, cy + 80, id(font_small), dark_green, TextAlign::CENTER, "%d %%", (brightness * 100) / 255);

          // Farbverlauf-Balken zeichnen (RGB)
          const int bar_x = 30;
          const int bar_y = 140;
          const int bar_w = 180;
          const int bar_h = 20;

          for (int x = 0; x < bar_w; x++) {
            float t = float(x) / float(bar_w - 1);
            uint8_t r, g, b;
            if (t < 1.0 / 6.0) {
              r = 255;
              g = uint8_t(t * 6.0f * 255.0f);
              b = 0;
            } else if (t < 2.0 / 6.0) {
              r = uint8_t((2.0f / 6.0f - t) * 6.0f * 255.0f);
              g = 255;
              b = 0;
            } else if (t < 3.0 / 6.0) {
              r = 0;
              g = 255;
              b = uint8_t((t - 2.0f / 6.0f) * 6.0f * 255.0f);
            } else if (t < 4.0 / 6.0) {
              r = 0;
              g = uint8_t((4.0f / 6.0f - t) * 6.0f * 255.0f);
              b = 255;
            } else if (t < 5.0 / 6.0) {
              r = uint8_t((t - 4.0f / 6.0f) * 6.0f * 255.0f);
              g = 0;
              b = 255;
            } else {
              r = 255;
              g = 0;
              b = uint8_t((1.0f - t) * 6.0f * 255.0f);
            }

            for (int y = 0; y < bar_h; y++) {
              it.draw_pixel_at(bar_x + x, bar_y + y, Color(r, g, b));
            }

            int delta = abs(int(r) - selected_color.r) + abs(int(g) - selected_color.g) + abs(int(b) - selected_color.b);
            if (delta < 40) {  // 30 ist die maximale Toleranz
              for (int y = -8; y < bar_h+8; y++) 
              {
                it.draw_pixel_at(bar_x + x, bar_y + y, Color(r, g, b));
              }
            }
            
          }

          // GerÃ¤temame unten
          it.print(cx, 220, id(font_small), darkest_green, TextAlign::CENTER, label.c_str());




      - id: p2000
        lambda: |-
          it.fill(black);
          const int cx = 120;
          const int cy = 120;

          // Home-Button oben
          it.image(100, 15, id(pageicon_00), id(shiny_green));
          it.image(cx - 50, cy - 50, id(pageicon_20_big), id(darkest_green)); 


          // MQTT Request senden
          // std::string topic = "m5dial/" + id(this_device) + "/get/light/" + entity;
          // id(mqtt_client)->publish(topic, "status");
          id(smart_mqtt_publish).execute("m5dial/" + id(this_device) + "/request/switches/rooms/" , "rooms", "GetSwitchesRooms",5000);


          // Leere Variable abfangen
          if (id(global_m5_switches_rooms).empty()) {
            ESP_LOGW("ui", "global_m5_switches_rooms ist leer â€“ keine RÃ¤ume anzuzeigen.");
            return;
          }
          // JSON parsen
          DynamicJsonDocument doc(2048);
          DeserializationError error = deserializeJson(doc, id(global_m5_switches_rooms));
          if (error) {
            ESP_LOGE("ui", "Fehler beim Parsen von global_m5_switches_rooms: %s", error.c_str());
            return;
          }
          JsonArray rooms = doc["rooms"];
          if (rooms.isNull() || rooms.size() == 0) {
            ESP_LOGW("ui", "Keine RÃ¤ume in global_m5_switches_rooms gefunden.");
            return;
          }




          // Raum auswÃ¤hlen per Subindex
          int room_index = id(selected_sub_index);
          if (room_index < 0) room_index = rooms.size() - 1;
          if (room_index >= rooms.size()) room_index = 0;
          id(selected_sub_index) = room_index;

          std::string current_room = rooms[room_index];
          id(selected_light_room) = current_room;
          // ESP_LOGD("p1000", "Zeige Raum-Index %d: %s", room_index, current_room.c_str());


          // Raumname zentriert anzeigen
          it.print(cx, cy - 50, id(font_middle), shiny_green, TextAlign::CENTER, current_room.c_str());


      - id: p20000
        lambda: |-
          it.fill(black);
          const int cx = 120;
          const int cy = 120;

          // MQTT Request senden
          id(smart_mqtt_publish).execute("m5dial/request/switches/rooms/" , "rooms", "GetSwitchesRooms",5000);


          // Leere Variable abfangen
          if (id(global_m5_switches_rooms).empty()) {
            ESP_LOGW("ui", "global_m5_switches_rooms ist leer â€“ keine RÃ¤ume anzuzeigen.");
            return;
          }
          // JSON parsen
          DynamicJsonDocument doc(2048);
          DeserializationError error = deserializeJson(doc, id(global_m5_switches_rooms));
          if (error) {
            ESP_LOGE("ui", "Fehler beim Parsen von global_m5_switches_rooms: %s", error.c_str());
            return;
          }
          JsonArray rooms = doc["rooms"];
          if (rooms.isNull() || rooms.size() == 0) {
            ESP_LOGW("ui", "Keine RÃ¤ume in global_m5_switches_rooms gefunden.");
            return;
          }


          // Home-Button oben
          it.image(100, 15, id(pageicon_00), id(shiny_green));
          it.image(cx - 50, cy - 50, id(pageicon_20_big), id(darkest_green)); 


          // Raum auswÃ¤hlen per Subindex
          int room_index = id(selected_sub_index);
          if (room_index < 0) room_index = rooms.size() - 1;
          if (room_index >= rooms.size()) room_index = 0;
          id(selected_sub_index) = room_index;

          std::string current_room = rooms[room_index];
          id(selected_light_room) = current_room;
          // ESP_LOGD("p1000", "Zeige Raum-Index %d: %s", room_index, current_room.c_str() );

          // MQTT Request senden
          id(smart_mqtt_publish).execute( "m5dial/" + id(this_device) + "/request/switches/room/" , current_room.c_str() , "GetSwitchesRoom",500);

          // Raumname zentriert anzeigen
          it.print(cx, cy - 52, id(font_middle), shiny_green, TextAlign::CENTER, current_room.c_str());

          // Switch von Device zentriert anzeigen
          // it.print(cx, cy - 30, id(font_middle), shiny_green, TextAlign::CENTER,  current_room.c_str());

          // Device unten
          // it.print(cx, 220, id(font_small), darkest_green, TextAlign::CENTER, current_room.c_str());


          // JSON parsen
          DynamicJsonDocument doc2(8192);
          DeserializationError err = deserializeJson(doc2, id(global_m5_switches_by_room));
          if (err) {
            ESP_LOGE("ui", "Fehler beim Parsen von global_m5_switches_by_room: %s", err.c_str());
            return;
          }

          JsonObject room_data = doc2.as<JsonObject>();
          std::vector<JsonObject> switch_list;
          std::vector<std::string> device_names;

          for (JsonPair kv : room_data) {
            std::string dev = kv.key().c_str();
            JsonArray switches = kv.value().as<JsonArray>();
            for (JsonObject sw : switches) {
              switch_list.push_back(sw);
              device_names.push_back(dev);
            }
          }

          if (switch_list.size() == 0) {
            it.print(cx, cy, id(font_middle), red, TextAlign::CENTER, "Keine Switches");
            return;
          }


          ESP_LOGD("p20000", "Switch count: %d", switch_list.size());
          // Subindex fÃ¼r Switch (rotary)
          int idx = id(selected_sub_sub_index);
          if (idx < 0) idx = 0;
          if (idx >= switch_list.size()) idx = switch_list.size() - 1;
          id(selected_sub_sub_index) = idx;

          JsonObject selected_switch = switch_list[idx];
          std::string dev = device_names[idx];
          const char* name = selected_switch["name"];
          const char* state = selected_switch["state"];

          // Entity_ID fÃ¼r changes
          id(selected_switch_entity) = (const char*) selected_switch["entity_id"];

          // GerÃ¤te-Name
          it.print(cx, cy - 30, id(font_middle), shiny_green, TextAlign::CENTER, dev.c_str());

          // Switch-Name
          // Wenn plug_name mit device_name beginnt â†’ abschneiden
          std::string plug_name = name;
          std::string display_name = plug_name;

          if (plug_name.find(dev + " ") == 0) {
            display_name = plug_name.substr(dev.length() + 1);
          }

          it.print(cx, cy - 8, id(font_middle), shiny_green, TextAlign::CENTER, display_name.c_str());


          // Symbol anzeigen
          if (strcmp(state, "on") == 0) 
          {
            it.image(cx - 24, cy + 10, id(pageicon_switch_on) , id(shiny_green) );
            it.image(cx + 60, cy + 10, id(pageicon_switch_on) , id(dark_green) );
            it.image(cx - 94, cy + 10, id(pageicon_switch_off) , id(shiny_red) );
          } 
          else if (strcmp(state, "off") == 0) 
          {
            it.image(cx - 24, cy + 10, id(pageicon_switch_off) , id(dark_red));
            it.image(cx + 60, cy + 10, id(pageicon_switch_on) , id(shiny_green) );
            it.image(cx - 94, cy + 10, id(pageicon_switch_off) , id(dark_red) );
          } 
          else 
          {
            it.image(cx - 24, cy + 10, id(pageicon_switch_una) , id(darkest_red));
            it.image(cx + 60, cy + 10, id(pageicon_switch_on) , id(darkest_red) );
            it.image(cx - 94, cy + 10, id(pageicon_switch_off) , id(darkest_red) );
          }

          // Footer
          char info[32];
          sprintf(info, "%d of %d", idx + 1, (int)switch_list.size());
          it.print(cx, 220, id(font_small), dark_green, TextAlign::CENTER, info);


      - id: p200000
        lambda: |-
          it.fill(black);
          const int cx = 120;
          const int cy = 120;

          //  // entity ist noch von vorgÃ¤ner seite vorhanden
          //  const char* entity = id(selected_switch_entity).c_str();
          //  // ESP_LOGD("touch", "POS (%s) x:%d y:%d ", entity , tx, ty );


          //  // MQTT Request senden
          //  id(smart_mqtt_publish).execute( "m5dial/" + id(this_device) + "/request/switches/room/" , current_room.c_str() , "GetSwitchesRoom",500);


          //  // JSON parsen
          //  DynamicJsonDocument doc2(8192);
          //  DeserializationError err = deserializeJson(doc2, id(global_m5_switches_by_room));
          //  if (err) {
          //    ESP_LOGE("ui", "Fehler beim Parsen von global_m5_switches_by_room: %s", err.c_str());
          //    return;
          //  }

          //  JsonObject room_data = doc2.as<JsonObject>();
          //  std::vector<JsonObject> switch_list;
          //  std::vector<std::string> device_names;

          //  for (JsonPair kv : room_data) {
          //    std::string dev = kv.key().c_str();
          //    JsonArray switches = kv.value().as<JsonArray>();
          //    for (JsonObject sw : switches) {
          //      switch_list.push_back(sw);
          //      device_names.push_back(dev);
          //    }
          //  }

          //  if (switch_list.size() == 0) {
          //    it.print(cx, cy, id(font_middle), red, TextAlign::CENTER, "Keine Switches");
          //    return;
          //  }


          //  ESP_LOGD("p20000", "Switch count: %d", switch_list.size());
          //  // Subindex fÃ¼r Switch (rotary)
          //  int idx = id(selected_sub_sub_index);
          //  if (idx < 0) idx = 0;
          //  if (idx >= switch_list.size()) idx = switch_list.size() - 1;
          //  id(selected_sub_sub_index) = idx;

          //  JsonObject selected_switch = switch_list[idx];
          //  std::string dev = device_names[idx];
          //  const char* name = selected_switch["name"];
          //  const char* state = selected_switch["state"];

          //  // Entity_ID fÃ¼r changes
          //  id(selected_switch_entity) = (const char*) selected_switch["entity_id"];

          //  // GerÃ¤te-Name
          //  it.print(cx, cy - 30, id(font_middle), shiny_green, TextAlign::CENTER, dev.c_str());

          // Switch-Name
          // Wenn plug_name mit device_name beginnt â†’ abschneiden
          //  std::string plug_name = name;
          //  std::string display_name = plug_name;

          //  if (plug_name.find(dev + " ") == 0) {
          //    display_name = plug_name.substr(dev.length() + 1);
          //  }

          //  it.print(cx, cy - 8, id(font_middle), shiny_green, TextAlign::CENTER, display_name.c_str());


          //  // Symbol anzeigen
          //  if (strcmp(state, "on") == 0) 
          //  {
          //    it.image(cx - 24, cy + 10, id(pageicon_switch_on) , id(shiny_green) );
          //    it.image(cx + 60, cy + 10, id(pageicon_switch_on) , id(dark_green) );
          //    it.image(cx - 94, cy + 10, id(pageicon_switch_off) , id(shiny_red) );
          //  } 
          //  else if (strcmp(state, "off") == 0) 
          //  {
          //    it.image(cx - 24, cy + 10, id(pageicon_switch_off) , id(dark_red));
          //    it.image(cx + 60, cy + 10, id(pageicon_switch_on) , id(shiny_green) );
          //    it.image(cx - 94, cy + 10, id(pageicon_switch_off) , id(dark_red) );
          //  } 
          //  else 
          //  {
          //    it.image(cx - 24, cy + 10, id(pageicon_switch_una) , id(darkest_red));
          //    it.image(cx + 60, cy + 10, id(pageicon_switch_on) , id(darkest_red) );
          //    it.image(cx - 94, cy + 10, id(pageicon_switch_off) , id(darkest_red) );
          //  }

          //  // Footer
          //  char info[32];
          //  sprintf(info, "%d of %d", idx + 1, (int)switch_list.size());
          //  it.print(cx, 220, id(font_small), dark_green, TextAlign::CENTER, info);


      - id: p3000
        lambda: |-
          it.fill(black);
          const int cx = 120;
          const int cy = 120;

          // Home-Button oben
          it.image(100, 15, id(pageicon_00), id(shiny_green));
          it.image(cx - 50, cy - 50, id(pageicon_30_big), id(darkest_green)); 


          // MQTT Request senden
          id(smart_mqtt_publish).execute("m5dial/" + id(this_device) + "/request/media/rooms/" , "rooms", "GetMediaRooms",5000);

          // Leere Variable abfangen
          if (id(global_m5_media_rooms).empty()) {
            ESP_LOGW("ui", "global_m5_media_rooms ist leer â€“ keine RÃ¤ume anzuzeigen.");
            return;
          }
          // JSON parsen
          DynamicJsonDocument doc(2048);
          DeserializationError error = deserializeJson(doc, id(global_m5_media_rooms));
          if (error) {
            ESP_LOGE("ui", "Fehler beim Parsen von global_m5_media_rooms: %s", error.c_str());
            return;
          }
          JsonArray rooms = doc["rooms"];
          if (rooms.isNull() || rooms.size() == 0) {
            ESP_LOGW("ui", "Keine RÃ¤ume in global_m5_media_rooms gefunden.");
            return;
          }

          // Raum auswÃ¤hlen per Subindex
          int room_index = id(selected_sub_index);
          if (room_index < 0) room_index = rooms.size() - 1;
          if (room_index >= rooms.size()) room_index = 0;
          id(selected_sub_index) = room_index;

          std::string current_room = rooms[room_index];
          id(selected_media) = current_room;
          // ESP_LOGD("p1000", "Zeige Raum-Index %d: %s", room_index, current_room.c_str());

          it.image(cx - 60 - 40, cy + 20, id(pageicon_media_volume_minus), id(shiny_green));
          it.image(cx + 60, cy + 20, id(pageicon_media_volume_plus), id(shiny_green));
          it.image(cx - 20, cy + 20, id(pageicon_media_volume_mute), id(shiny_green));
          it.image(cx - 20, cy + 70, id(pageicon_media_standby), id(shiny_green));  

          // Raumname zentriert anzeigen
          it.print(cx, cy - 50, id(font_middle), shiny_green, TextAlign::CENTER, current_room.c_str());


      - id: p30000
        lambda: |-
          it.fill(black);
          const int cx = 120;
          const int cy = 120;

          // Home-Button oben
          it.image(100, 15, id(pageicon_00), id(shiny_green));
          it.image(cx - 50, cy - 50, id(pageicon_30_big), id(darkest_green)); 

          // MQTT Request senden
          const char* room_entity = id(selected_media).c_str();
          id(smart_mqtt_publish).execute("m5dial/" + id(this_device) + "/request/media/room/" + room_entity , room_entity, "GetMediaRoom",1000);

          // Leere Variable abfangen  - ROOMS
          if (id(global_m5_media_rooms).empty()) {
            ESP_LOGW("ui", "global_m5_media_rooms ist leer â€“ keine RÃ¤ume anzuzeigen.");
            return;
          }
          // JSON parsen - rooms
          DynamicJsonDocument doc(2048);
          DeserializationError error = deserializeJson(doc, id(global_m5_media_rooms));
          if (error) {
            ESP_LOGE("ui", "Fehler beim Parsen von global_m5_media_rooms: %s", error.c_str());
            return;
          }
          JsonArray rooms = doc["rooms"];
          if (rooms.isNull() || rooms.size() == 0) {
            ESP_LOGW("ui", "Keine RÃ¤ume in global_m5_media_rooms gefunden.");
            return;
          }

          // Leere Variable abfangen  - PLAYERS
          if (id(global_m5_media_by_room).empty()) {
            ESP_LOGW("ui", "global_m5_media_by_room ist leer â€“ keine Player anzuzeigen.");
            return;
          }
          // JSON parsen - players in room
          DynamicJsonDocument doc_by_room(2048);
          DeserializationError error_by_room = deserializeJson(doc_by_room, id(global_m5_media_by_room));
          if (error_by_room) {
            ESP_LOGE("ui", "Fehler beim Parsen von global_m5_media_by_room: %s", error_by_room.c_str());
            return;
          }

          // Zugriff auf das Array unter dem Key "room"
          JsonArray room_players = doc_by_room["room"];
          if (room_players.isNull() || room_players.size() == 0) {
            ESP_LOGW("ui", "Keine Players im ROOM in global_m5_media_by_room gefunden.");
            return;
          }

          // Durch alle RÃ¤ume iterieren
          // for (JsonObject room_entry : room_players) 
          // {
          //   JsonArray players = room_entry["players"];
          //   for (JsonObject player : players) 
          //   {
          //     std::string entity_id = player["entity_id"].as<std::string>();
          //     std::string name = player["name"].as<std::string>();
          //     std::string state = player["state"].as<std::string>();
          //     ESP_LOGI("media_player", "Player: %s (%s) â†’ Status: %s", name.c_str(), entity_id.c_str(), state.c_str());
          //   }
          // }

          // Direktes Extrahieren der players-Liste aus dem ersten Raumeintrag
          JsonObject first_room = room_array[0];
          JsonArray players = first_room["players"];
          if (players.isNull() || players.size() == 0) {
            ESP_LOGW("ui", "Keine Players im ersten Raum gefunden.");
            return;
          }

          // Zugriff auÃŸerhalb der Schleife mÃ¶glich
          for (JsonObject player : players) {
            std::string entity_id = player["entity_id"].as<std::string>();
            std::string name = player["name"].as<std::string>();
            std::string state = player["state"].as<std::string>();
            // ESP_LOGI("media_player", "Player: %s (%s) â†’ Status: %s", name.c_str(), entity_id.c_str(), state.c_str());
          }

          // Raum auswÃ¤hlen per Subindex
          int room_index = id(selected_sub_index);
          if (room_index < 0) room_index = rooms.size() - 1;
          if (room_index >= rooms.size()) room_index = 0;
          id(selected_sub_index) = room_index;

          std::string current_room = rooms[room_index];
          id(selected_media) = current_room;

          // Player auswÃ¤hlen per SUB-Subindex
          int player_index = id(selected_sub_sub_index);
          if (player_index < 0) player_index = players.size() - 1;
          if (player_index >= rooms.size()) player_index = 0;
          id(selected_sub_sub_index) = player_index;

          std::string current_player_id = players[player_index]["entity_id"];
          std::string current_player_name = players[player_index]["name"];
          std::string current_player_state = players[player_index]["state"];
          id(selected_media) = current_room;

          it.image(cx - 60 - 40, cy + 20, id(pageicon_media_volume_minus), id(shiny_green));
          it.image(cx + 60, cy + 20, id(pageicon_media_volume_plus), id(shiny_green));
          it.image(cx - 20, cy + 20, id(pageicon_media_volume_mute), id(shiny_green));
          it.image(cx - 20, cy + 70, id(pageicon_media_standby), id(shiny_green));  

          it.image(cx - 60 - 40, cy - 30, id(pageicon_media_stop), id(shiny_green));
          it.image(cx - 20, cy - 30, id(pageicon_media_play_pause), id(shiny_green));
          it.image(cx + 60, cy - 30, id(pageicon_media_play), id(shiny_green));

          // Raumname zentriert anzeigen
          it.print(cx, cy - 58, id(font_small), dark_green, TextAlign::CENTER, current_room.c_str());
          // Player zentriert anzeigen
          it.print(cx, cy - 50, id(font_middle), shiny_green, TextAlign::CENTER, current_player_name.c_str());

